[{"content":"比赛链接 https://codeforces.com/gym/624051\n题目及题解 A 题（对应原题： https://codeforces.com/contest/1674/problem/A\n问题分析 题目要求找到满足特定条件的整数$ a $和$ b $，核心是理解题目中的过程可以重新表述为 “用$ ab $乘以$ x $”。根据数学性质，$ x \\cdot ab $必然能被$ x $整除，因此若$ y $不能被$ x $整除，则不存在符合条件的$ a $和$ b $；若$ y $能被$ x $整除，则可以简单地令$ a=1 $且$ b=y/x $。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //#pragma GCC optimize(2) #include \u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#34;\\n\u0026#34; #define int long long using namespace std; const int N = 1e6+10; const int inf = 1e18+10; void solve() { int x,y;cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int a = y/x; if(y%x) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; return; } cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } B 题 https://codeforces.com/gym/105423/problem/C\n问题分析 本题需要比较乘积的大小，直接计算可能会因数值过大而溢出。可以通过对乘积式子取对数，将乘法运算转化为加法运算来比较大小。也可以使用高精度计算或利用 2024 与 2048 的关系（因为$ (2024/2048)^{50} \u0026gt; 0.5 $）通过 2 的幂次比较。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //#pragma GCC optimize(2) #include \u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#34;\\n\u0026#34; #define int long long using namespace std; const int N = 1e6+10; const int inf = 1e18+10; int n; void solve() { int sum = 0; cin \u0026gt;\u0026gt; n; for(int i=1;i\u0026lt;=n;i++) { int a;cin \u0026gt;\u0026gt; a; sum += log2(a); } cout \u0026lt;\u0026lt; ceil(sum*1.0/log2(2024)) \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; //cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } C 题 https://codeforces.com/gym/105257/problem/F\n问题分析 题目中提到代码可以重复提交，要获得最高得分，最优策略显然是每次都提交得分最高的代码，因此只需遍历数组找到最大值并输出即可。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //#pragma GCC optimize(2) #include \u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#34;\\n\u0026#34; #define int long long using namespace std; const int N = 1e6+10; const int inf = 1e18+10; void solve() { int n;cin \u0026gt;\u0026gt; n; int mx = -1; for(int i=1;i\u0026lt;=n;i++) { int t;cin \u0026gt;\u0026gt; t; mx = max(mx,t); } cout \u0026lt;\u0026lt; mx \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } D 题 https://codeforces.com/contest/1772/problem/D\n问题分析 要使\n$ |a_1 - x| \\le |a_2 - x| \\le \\cdots \\le |a_n - x| $\n成立，只需考虑相邻两项的约束。\n对每个$ i=1,2,\\dots,n-1 $：$ |a_i - x| \\le |a_{i+1} - x| $\n等价于\n$ (a_i - x)^2 \\le (a_{i+1} - x)^2 \\implies 2x(a_{i+1} - a_i) \\le (a_{i+1}^2 - a_i^2) \\implies 2x(a_{i+1} - a_i) \\le (a_{i+1} - a_i)(a_{i+1} + a_i) $\n如果$ a_{i+1} \u0026gt; a_i $，两边同除以正数$ (a_{i+1} - a_i) $，得$ 2x \\le a_i + a_{i+1} \\implies x \\le \\left\\lfloor \\frac{a_i + a_{i+1}}{2} \\right\\rfloor $\n如果$ a_{i+1} \u0026lt; a_i $，除以负数要反向不等号，得$ 2x \\ge a_i + a_{i+1} \\implies x \\ge \\left\\lceil \\frac{a_i + a_{i+1}}{2} \\right\\rceil $\n如果$ a_{i+1} = a_i $，则毫无限制。\n把所有$ i $的约束合并，就是求一个整数区间$ [L, R] $：\n初始化$ L = -\\infty, R = +\\infty $。 遍历$ i=1\\ldots n-1 $：若$ a_i \u0026lt; a_{i+1} $，令$ R = \\min\\left(R, \\left\\lfloor \\frac{a_i + a_{i+1}}{2} \\right\\rfloor \\right) $ 若$ a_i \u0026gt; a_{i+1} $，令$ L = \\max\\left(L, \\left\\lceil \\frac{a_i + a_{i+1}}{2} \\right\\rceil \\right) $\n若$ L \\le R $，区间非空，任选一个$ x \\in [L, R] $（比如$ x = L $）即可；否则无解，输出$ -1 $。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //#pragma GCC optimize(2) #include \u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#34;\\n\u0026#34; #define int long long using namespace std; const int N = 1e6+10; const int inf = 1e18+10; void solve() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; a(n); for(int i= 0;i\u0026lt;n;i++) cin \u0026gt;\u0026gt; a[i]; int l = 0, r = 1e9; for(int i=0;i\u0026lt;n-1;i++) { if(a[i]\u0026lt;a[i+1]) { int nr = (a[i]+a[i+1]) / 2; r = min(r,nr); } else if(a[i]\u0026gt;a[i+1]) { int nl = ceil((a[i]+a[i+1])*1.0/2); l = max(l,nl); } if(l\u0026gt;r) { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } E 题 https://codeforces.com/contest/2051/problem/E\n问题分析 本题可设计时间复杂度为$ O(n^2) $的解法，通过检查$ a $和$ b $并集中的整数作为可能价格来优化。采用事件处理（扫描线算法），按升序处理所有可能价格，维护树的购买数量和负面评价数量，更新答案。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while (t--) { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; vector\u0026lt;int\u0026gt; a(n), b(n); for (auto \u0026amp;x : a) cin \u0026gt;\u0026gt; x; for (auto \u0026amp;x : b) cin \u0026gt;\u0026gt; x; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; ev; for (int i = 0; i \u0026lt; n; ++i) { ev.emplace_back(a[i], 1); ev.emplace_back(b[i], 2); } sort(ev.begin(), ev.end()); long long ans = 0; int cnt = n, bad = 0; for (int i = 0; i \u0026lt; 2 * n;) { auto [x, y] = ev[i]; if (bad \u0026lt;= k) ans = max(ans, x * 1LL * cnt); while (i \u0026lt; 2 * n \u0026amp;\u0026amp; ev[i].first == x) { bad += (ev[i].second == 1); bad -= (ev[i].second == 2); cnt -= (ev[i].second == 2); ++i; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } F 题 https://codeforces.com/gym/105386/problem/E\n问题分析 给定正整数序列$ a_1, a_2, \\cdots, a_n $与非负整数$ k $，可以执行至多一次操作：选择一个连续子数组，并把所有元素加$ k $。最大化整个序列的最大公因数。$ n \\le 3 \\times 10^5 $，$ k \\le 10^{18} $。\n假设选择的区间是$ [l, r] $，那么整个序列的最大公因数就是以下四项的最大公因数：\n$ \\gcd(a_1, a_2, \\cdots, a_{l-1}), \\gcd(|a_l - a_{l+1}|, |a_{l+1} - a_{l+2}|, \\cdots, |a_{r-1} - a_r|), a_r + k, \\gcd(a_{r+1}, a_{r+2}, \\cdots, a_n) $\n如果$ r $的值是确定的，那么后两项的值都是确定的。接下来考虑$ l $的值如何影响前两项。\n注意到前缀$ \\gcd $的值只有$ \\log X $种。 而且因为$ r $是确定的，所以$ l $越大，第二项越大，且变大后是之前的倍数。 所以对于固定的前缀$ \\gcd $，$ l $越大越好。因此枚举$ \\log X $个前缀$ \\gcd $即将变小的地方，再枚举所有$ r $即可。含计算$ \\gcd $的复杂度，均摊后$ O(n \\log X) $。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;bits/stdc++.h\u0026gt; using i64 = long long; i64 gcd(i64 x, i64 y) { if (x == 0) return y; if (y == 0) return x; return std::gcd(x, y); } void Solve() { int n; i64 K; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; K; std::vector\u0026lt;i64\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) std::cin \u0026gt;\u0026gt; a[i]; std::vector\u0026lt;i64\u0026gt; g(n + 1), suf(n + 2); for (int i = 1; i \u0026lt;= n; ++i) g[i] = gcd(g[i - 1], a[i]); for (int i = n; i \u0026gt; 0; --i) suf[i] = gcd(suf[i + 1], a[i]); i64 ans = g[n]; for (int i = 1; i \u0026lt;= n; ++i) if (g[i] != g[i - 1]) { i64 gc = g[i - 1]; for (int j = i; j \u0026lt;= n; ++j) { gc = gcd(gc, a[j] + K); ans = std::max(ans, gcd(gc, suf[j + 1])); } } std::cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); int t; std::cin \u0026gt;\u0026gt; t; for (int ti = 1; ti \u0026lt;= t; ++ti) { Solve(); } return 0; } ","date":"2025-07-23T00:00:00Z","permalink":"https://zephyrbd.github.io/p/dsacontesttwotutorial/","title":"DSA训练赛二题解（AI汇总）"},{"content":"树链剖分（HLD） 基本概念 树链剖分（Heavy - Light Decomposition，HLD）是一种将树分解为若干条链的数据结构和算法，其目的是便于在树上进行路径查询和更新操作。通过这种分解方式，能将树上的复杂路径问题转化为对链的操作，从而可以利用线段树、平衡树等数据结构高效地处理。\n核心思想 树链剖分的核心思想是对树的节点进行重轻分类。对于每个节点，将其孩子中拥有最大子树的那个孩子称为重孩子，其余孩子称为轻孩子。由重孩子组成的链称为重链，轻孩子则作为新的链的起点。通过这样的划分，树上的任意路径都可分解为少数几条链，进而能利用数据结构对这些链进行高效操作。\n实现步骤 相关定义 重儿子：对于一个节点，其所有子节点中，子树大小最大的子节点（若有多个子树大小相同且最大的情况，任选其一）。\n轻儿子：除重儿子外的其他子节点。\n重边：连接节点与其重儿子的边。\n轻边：连接节点与其轻儿子的边。\n重链：由重边连接而成的链，即从一个节点（非重儿子）开始，通过重边依次连接重儿子所形成的链。\n预处理 第一次 DFS 计算每个节点的深度（dep）。\n记录每个节点的父节点（fa）。\n计算每个节点的子树大小（sz）。\n确定每个节点的重儿子（son）。\n第二次 DFS 为每个节点分配一个新的编号（idx），使同一重链上的节点编号连续，便于后续使用线段树等数据结构进行操作。\n记录每个节点所在重链的链头（top）。\n具体操作 路径查询 / 更新：对于树上任意两个节点 u 和 v，将路径 u - v 分解为 u 到 LCA（最近公共祖先）和 v 到 LCA 两段。在每一段中，从节点向上移动，若当前节点与链头在同一条重链上，则直接对该段进行操作；否则，操作从当前节点到链头的重链，然后移动到链头的父节点，重复上述过程，直到到达 LCA。\n子树查询 / 更新：由于子树在新的编号下是连续的，因此可以直接通过子树的根节点的编号和子树大小确定查询 / 更新的区间。\n视频讲解 LCA 轻重链 应用场景 树上路径的最值查询、求和、更新等操作。\n解决与树的直径、LCA 相关的复杂问题。\n在一些图论问题中，将树结构转化为链结构后进行处理。\n两次DFS的代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int pre_wealth[N],dep[N],sz[N],son[N],fa[N],top[N],idx[N],nw[N],cnt; vector\u0026lt;int\u0026gt; g[N]; void depdfs(int u,int father) { fa[u] = father,dep[u]=dep[father]+1,sz[u] = 1; for(auto v : g[u]) { if(v==father) continue; depdfs(v,u); sz[u] += sz[v]; if(sz[son[u]]\u0026lt;sz[v]) son[u] = v; } } void dfs(int u,int t) { top[u] = t; idx[u] = ++cnt; nw[cnt] = pre_wealth[u]; if(!son[u]) return; dfs(son[u],t); for(auto v : g[u]) { if(v==fa[u] or v==son[u]) continue; dfs(v,v); } } 寻找LCA的应用 基本题 P3379 【模板】最近公共祖先（LCA）\nP5903 【模板】树上 K 级祖先\n拓展题——[苹果树]： 问题描述:\n给出一棵包含 $ n $ 个点的树，每个节点 $ i $ 都有一个权值 $ a_i $。\n有 $ m $ 次操作，每次操作都形如以下的两种：\n1 x y：查询 $ x $ 到 $ y $ 的路径上，最大的点权权值。\n2 x z：对于所有与 $ x $ 直接相连的点 $ i $，令 $ a_i \\leftarrow a_i + z $。\n不保证查询的 $ x, y $ 满足 $ x \\neq y $。\n输入:\n每个测试点中包含多组测试数据。输入的第一行包含一个正整数 $ T $（$ 1 \\leq T \\leq 110 $），表示数据组数。对于每组测试数据：\n第一行两个正整数 $ n, m $（$ 1 \\leq n, m \\leq 10^5 $）。\n第二行 $ n $ 个整数 $ a_1, a_2, \\cdots, a_n $（$ 1 \\leq a_i \\leq 10^4 $），表示初始每个节点的点权。\n接下来 $ n-1 $ 行，每行两个正整数 $ x, y $（$ 1 \\leq x, y \\leq n $），表示有一条从 $ x $ 到 $ y $ 的无向边。\n接下来 $ m $ 行，每行三个整数，第一个数 $ opt $ 表示操作类型：\n若 $ opt=1 $，则后面两个数 $ x, y $（$ 1 \\leq x, y \\leq n $），表示询问路径。 若 $ opt=2 $，则后面两个数 $ x, z $（$ 1 \\leq x \\leq n, 1 \\leq z \\leq 10^4 $），分别表示修改中心以及增加的值。保证所有测试数据中 $ n $ 之和与 $ m $ 之和均不超过 $ 4 \\times 10^5 $。 输出:\n对于每组测试数据：对于每一个 $ opt=1 $ 的操作，输出一行一个数表示答案。\n样例输入:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1 5 10 3 7 9 1 6 2 1 3 1 4 2 5 4 2 1 2 2 5 3 1 1 4 1 3 1 2 4 3 2 2 9 2 1 5 1 4 2 2 3 4 1 4 4 样例输出:\n1 2 3 4 9 11 17 13 思路：\n采用重链剖分结合线段树解决树上路径最大权值查询与邻接点更新问题。\n先通过两次 DFS 完成重链剖分，将树分解为若干重链，使每条链节点在线段树中对应连续区间。\n用线段树维护重链节点权值，支持区间查询和单点更新。\n对节点邻接点更新，重儿子和父节点通过线段树更新，轻儿子用 flag 数组记录累计更新。\n路径查询时，分解路径为多个重链区间，查各区间最大值并结合 flag 数组补充轻儿子实际权值，取最大结果。\nHLD模板代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 struct HLD { int n; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g; vector\u0026lt;int\u0026gt; dep, sz, son, fa, top, idx, out, HLD_data; int cnt; HLD() {} HLD(int _n) { init(_n); } void init(int _n) { n = _n; g.resize(n+1, {}); dep.resize(n+1, 0); sz.resize(n+1, 0); son.resize(n+1, 0); fa.resize(n+1, 0); top.resize(n+1, 0); idx.resize(n+1, 0); out.resize(n+1, 0); HLD_data.resize(n+1, 0); cnt = 0; } void addEdge(int u, int v) { g[u].push_back(v); g[v].push_back(u); } void prework(int root = 1) { cnt = 0; depdfs(root, 0); dfs(root, root); } // 第一次 DFS：计算 sz, dep, son, fa void depdfs(int u, int father) { fa[u] = father; dep[u] = dep[father] + 1; sz[u] = 1; son[u] = 0; for (int v : g[u]) { if (v == father) continue; depdfs(v, u); sz[u] += sz[v]; if (sz[v] \u0026gt; sz[son[u]]) son[u] = v; } } // 第二次 DFS：分链，给 idx、top、out 赋值 void dfs(int u, int t) { top[u] = t; idx[u] = ++cnt; HLD_data[cnt] = u; // 先重儿子 if (son[u]) dfs(son[u], t); // 再轻儿子 for (int v : g[u]) { if (v == fa[u] || v == son[u]) continue; dfs(v, v); } // 无论是不是叶子，都在此处给 out[u] 赋值 out[u] = cnt; } int query_lca(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] \u0026lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; } return dep[u] \u0026lt; dep[v] ? u : v; } int query_klca(int u, int k) // 求 x 的第 k 个祖先（0 表示 x 本身） { if (dep[u] \u0026lt; k) return -1; int fa_dep = dep[u] - k; // 跳到那条重链的顶，直到该链顶部深度 ≤ fa_dep while (dep[top[u]] \u0026gt; fa_dep) u = fa[top[u]]; // 链内直接跳：当前节点在序 idx[u]，它的深度是 dep[u]， // 要到深度 fa_dep 的节点，走 idx 减去 dep[u]-fa_dep return HLD_data[idx[u] - (dep[u] - fa_dep)]; } bool isAncester(int u, int v) { // [idx[u], out[u]] 包含所有子节点 return idx[u] \u0026lt;= idx[v] \u0026amp;\u0026amp; idx[v] \u0026lt;= out[u]; } int dist(int u, int v) { return dep[u] + dep[v] - 2 * dep[query_lca(u, v)]; } int rootedParent(int u, int v) // 在以 u 为根的树中，查询 v 的父节点（朝向 u 的方向） { swap(u, v); if (u == v) return u; // 若 u 不是 v 的祖先，则 u 的父亲就是答案 if (!isAncester(u, v)) return fa[u]; // 否则在 u 的孩子里，找一条链带 v 下去的那位 auto it = upper_bound(g[u].begin(), g[u].end(), v, [\u0026amp;](int a, int b) { return idx[a] \u0026lt; idx[b]; }) - 1; return *it; } int rootedSize(int u, int v) // 在以 u 为根的树中，计算 v 子树的大小 { if (u == v) return n; // 如果 v 不是 u 的子孙，则就是普通子树大小 if (!isAncester(v, u)) return sz[v]; // 如果 v 是 u 的祖先，则去掉通向 u 那条孩子的子树 return n - sz[rootedParent(u, v)]; } int rootedLca(int a, int b, int c) // 三点 LCA：利用性质 LCA(a,b,c)=LCA(a,b)^LCA(a,c)^LCA(b,c) { return query_lca(a, b) ^ query_lca(a, c) ^ query_lca(b, c); } /*配合线段树使用 int query_path(int u,int v) { int res = -inf; while(top[u]!=top[v]) { if(dep[top[u]]\u0026lt;dep[top[v]]) swap(u,v); // if(fa[u]!=0 and son[fa[u]]!=u) // res = max(res,query(tree,1,1,n,idx[u],idx[u])+flag[fa[u]]); // if(fa[v]!=0 and son[fa[v]]!=v) // res = max(res,query(tree,1,1,n,idx[v],idx[v])+flag[fa[v]]); res += query(tree,1,1,n,idx[top[u]],idx[u])); // if(fa[top[u]]!=0 and son[fa[top[u]]]!=top[u]) // res = max(res,query(tree,1,1,n,idx[top[u]],idx[top[u]])+flag[fa[top[u]]]); u = fa[top[u]]; } if(dep[u]\u0026lt;dep[v]) swap(u,v); // if(fa[u]!=0 and son[fa[u]]!=u) // res = max(res,query(tree,1,1,n,idx[u],idx[u])+flag[fa[u]]); // if(fa[v]!=0 and son[fa[v]]!=v) // res = max(res,query(tree,1,1,n,idx[v],idx[v])+flag[fa[v]]); res += query(tree,1,1,n,idx[v],idx[u]); return res; } */ }; ","date":"2025-07-22T00:00:00Z","permalink":"https://zephyrbd.github.io/p/hld/","title":"树链剖分（HLD）"},{"content":"环的寻找：Tarjan算法 在图论中，强连通图和强连通分量是针对有向图的重要概念。它们描述了图中节点之间的可达性和结构特性。\n强连通图 (Strongly Connected Graph) 定义： 如果有向图中任意两个节点之间都存在双向路径（即从节点A到节点B和从节点B到节点A都有路径），则称该图为强连通图。 关键点：\n双向可达性：每个节点都能到达其他所有节点。 整体性质：强连通性是图的整体性质，而非局部性质。 示例： 一个环图（如节点1→2→3→1）是强连通的。 城市中的单向道路网络若构成强连通图，则任意两个地点之间可以互相到达。 强连通分量 (Strongly Connected Component, SCC) 定义： 有向图的极大强连通子图称为强连通分量（SCC）。\n极大：若再加入任何其他节点，该子图将不再强连通。 关键点： 局部结构：强连通分量是图的局部结构，将图分解为多个“强连通块”。 分解特性：每个节点恰好属于一个SCC，不同SCC之间的边是单向的（否则可合并为更大的SCC）。 强连通图 vs 强连通分量 强连通图 强连通分量 整个图满足强连通性 图的子图满足强连通性 所有节点互相可达 仅分量内的节点互相可达 图本身是一个整体SCC 图可分解为多个SCC 例如：环图、完全有向图 例如：非强连通图中的环结构 计算强连通分量的算法 常用算法有：\nKosaraju算法：两次DFS，第一次处理原图，第二次处理反向图。 Tarjan算法：一次DFS，使用栈和时间戳（如用户代码中使用的算法）。 Gabow算法：Tarjan算法的变种，优化了栈操作。 Tarjan算法（寻找最大SCC） 时间戳的引入 我们利用一个lowvis[N]和一个dfn[N]数组来记录DFS的过程，一个全局变量timestramp来表示时间，以便知道每个节点的先后访问顺序。\n代码实现 找最大连通分量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 int inStack[N]; int dfn[N],low[N]; stack\u0026lt;int\u0026gt; st; vector\u0026lt;int\u0026gt; g[N]; int scc[N],sz[N]; int timestramp; int cnt; void dfs(int u) { st.push(u); low[u] = dfn[u] = ++timestramp; inStack[u] = true; for(auto v : g[u]) { if(!dfn[v]) { dfs(v); low[u] = min(low[v],low[u]); } else if(inStack[v]) low[u] = min(low[v],low[u]); } if(dfn[u]==low[u]) { cnt++; do { inStack[st.top()] = false; scc[st.top()] = cnt; sz[cnt]++; st.pop(); }while(st.top()!=u); } } ","date":"2025-07-21T00:00:00Z","permalink":"https://zephyrbd.github.io/p/tarjan/","title":"Tarjan算法"},{"content":"算法板子的扩大化思路（长期更新） 数字量偏移的01背包 例题：P2340 Cow Exhibition G 思路： 1.DP的想法\nQ： 为啥要用01背包而不是其它算法？ A：我们发现，每只奶牛只有选和不选两种状态，而且是需要决策的，所以01背包绝对是最好的选择 01背包中，一定要想好什么是体积，什么是价值，什么是背包容量。此题中，我们可以把体积看成奶牛的智商，背包容量看成奶牛的个数，价值看成奶牛的情商。每只牛有两种选择：参加会展和不参加会展。我们要求在智商一定的情况下情商的最大值，这其实就是01背包的模板。状态转移方程的推导如下：\n第 i 只奶牛不参加会展：$dp[i][j]=dp[i−1][j]$ 第 i 只奶牛参加会展：$dp[i][j]=dp[i−1][j−a[i].iq]+a[i].eq$ 加上决策，选取上面两种情况的最大值：$dp[i][j]=max(dp[i−1][j],dp[i−1][j−a[i].iq]+a[i].eq)$ 2.数字量偏移详解\ndp[i] 表示「经过偏移处理后，下标为 i 时，对应的实际智商和为 i - tot，此时的最大情商和为 dp[i]」\n这里的 tot 是偏移量（在代码中等于 n*1000），它的作用是将可能出现的负数智商和映射到数组的非负下标上。例如：\n当实际智商和为 0 时，对应的数组下标是 tot（因为 0 + tot = tot）。 当实际智商和为 正数（如 5）时，对应的数组下标是 tot + 5。 当实际智商和为 负数（如 - 5）时，对应的数组下标是 tot - 5。 因为数组下标不能是负数，但我们需要处理智商和为负数的情况。通过引入 tot 作为偏移量：\ni \u0026lt; tot 的部分：对应实际智商和为负数（例如 i = tot - 10 对应实际智商和为 -10）。 i = tot 的部分：对应实际智商和为 0（初始状态）。 i \u0026gt; tot 的部分：对应实际智商和为正数（例如 i = tot + 10 对应实际智商和为 +10）。 特别的：中间态实际上会出现一个花费背包空间为负的物品需要放入，此时会从比更大的背包转移，所以是正序遍历。需要注意的是：我们只对$j$这个变量做了偏移处理！\nSTD: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;bits/stdc++.h\u0026gt; #define int long long #define endl \u0026#34;\\n\u0026#34; using namespace std; const int N = 2e5+10; struct node { int u,v; }; node ipt[N]; int dp[N]; void solve() { int n;cin \u0026gt;\u0026gt; n; for(int i=1;i\u0026lt;=n;i++) cin \u0026gt;\u0026gt; ipt[i].u \u0026gt;\u0026gt; ipt[i].v; int tot = n*1000; for(int i=0;i\u0026lt;=tot*2;i++) dp[i] = -1e8; dp[tot] = 0; for(int i=1;i\u0026lt;=n;i++) { if(ipt[i].u\u0026lt;0 and ipt[i].v\u0026lt;0) continue; if(ipt[i].u\u0026lt;0) { for(int j=0;j\u0026lt;=tot*2+ipt[i].u;j++) dp[j] = max(dp[j],dp[j-ipt[i].u]+ipt[i].v); } else { for(int j=tot*2;j\u0026gt;=ipt[i].u;j--) dp[j] = max(dp[j],dp[j-ipt[i].u]+ipt[i].v); } } int ans = -1; for(int i=tot;i\u0026lt;=2*tot;i++) { if(dp[i]\u0026lt;0) continue; ans = max(ans,dp[i]+i-tot); } cout \u0026lt;\u0026lt; (ans==-1 ? 0 : ans) \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; //cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } 单调队列+01背包问题 例题：P2627 Mowing the Lawn G 思路： 1.dp的思路来源\n我们发现，对于每个奶牛，我们要考虑选还是不选，于是有了第一种想法：\n对于一头奶牛，如果我们不选，则有:$dp[i][0] = max(dp[i-1][0],dp[i-1][0])$ 那考虑选这头奶牛：\n从第一头奶牛开始看，我们发现到了第$k+1$头的时候，需要满足第二个条件，即不能连续的超过$k$头，如果我们要选择这头奶牛的话，意味着前面$k$头需要考虑一头不选，这头不选的设为$j,j\\in(1\\le j \\le k)$，并且，如果我们不选$j$，那么在$j$到$i$之间会出现$[j+1,i-1]$是会被选择的，所以总的来看，对于第$k+1$头牛而言，选它的转移为\n$$ dp[k+1][1] = max\\{dp[j][0]+sum[k]-sum[j],j\\in[1,k]\\} $$推广到任意一头牛，则有$j\\in(i-k\\le j \\le i-1)$，那么需要找出这个区间中最大的那个$dp[j][0]$，那么转移方程为：\n$$ dp[i][1] = max\\{dp[j][0]-sum[j],j\\in[i-k,i-1]\\}+sum[i-1] $$2.单调队列的思路来源\n我们发现，对于第$i$头牛而言，总是需要维护一个最大值：\n$$ mx = max\\{dp[j][0]-sum[j],j\\in[i-k,i-1]\\} $$于是考虑最大最小值动态维护的办法：单调队列+滑动窗口。\nSTD： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;bits/stdc++.h\u0026gt; #define int long long #define endl \u0026#34;\\n\u0026#34; using namespace std; const int N = 2e5+10; int n,k; int pre[N]; int dp[N][2]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i=1;i\u0026lt;=n;i++) { int t;cin \u0026gt;\u0026gt; t; pre[i] = pre[i-1] + t; } deque\u0026lt;int\u0026gt; dq; dq.push_back(0); for(int i=1;i\u0026lt;=n;i++) { dp[i][0] = max(dp[i-1][0],dp[i-1][1]); while(!dq.empty() and dq.front()\u0026lt;i-k) dq.pop_front(); dp[i][1] = dp[dq.front()][0] + pre[i] - pre[dq.front()]; while(!dq.empty() and dp[dq.back()][0] - pre[dq.back()] \u0026lt; dp[i][0] - pre[i]) dq.pop_back(); dq.push_back(i); } cout \u0026lt;\u0026lt; max(dp[n][1],dp[n][0]) \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; //cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } ","date":"2025-07-14T00:00:00Z","permalink":"https://zephyrbd.github.io/p/oeat/","title":"算法板子的扩大化思路（长期更新）"},{"content":"二分图问题 什么是二分图: 若图 $G=(V,E) $的顶点集 V 可分为两个非空子集 $U$ 和 $W$ $（U∩W=∅，U∪W=V）$，使得每条边 $e∈E$ 的两个端点分别属于 $U$ 和 $W$，则 $G$ 为二分图，记为 $G=(U,W,E)$。\n二分图中不存在奇数长度的环（如三角形）。若图中存在奇数环，则必不是二分图，这是二分图的重要性质。\n举例: 学生选课关系图 图的构造\n顶点集合： $U =$ 所有学生（如学生 A、B、C）， $W = $所有课程（如课程 X、Y、Z）。 边的定义：若学生选了某门课，则学生与课程之间连一条边。 二分图验证: 顶点二分性：学生和课程是两类不同的对象，集合 U 和 W 无交集。 边的跨组性：边只存在于 “学生→课程” 之间，不存在 “学生→学生” 或 “课程→课程” 的边（选课关系不涉及学生之间或课程之间的直接连接）。 无奇数环：假设学生 A 选了课程 X，课程 X 被学生 B 选，学生 B 选了课程 Y，课程 Y 被学生 A 选，形成环 “学生 A→课程 X→学生 B→课程 Y→学生 A”，环的长度为 4（偶数），不存在奇数环（如 3 个顶点的环：学生 A→课程 X→学生 B→学生 A，这种情况不可能出现，因为学生之间没有边）。 判断方法: 染色法（常用判定算法）\n从任意未染色顶点出发，将其染为颜色 A，然后将相邻顶点染为颜色 B，再将相邻顶点的相邻顶点染为颜色 A，以此类推。 若染色过程中发现相邻顶点颜色相同，则图中存在奇数环，不是二分图；否则是二分图。 时间复杂度：$(O(V + E))$，适用于所有图。 数学性质判定 图是二分图当且仅当它没有奇数长度的环（如 3 - 环、5 - 环等）。\n染色法实现: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 vector\u0026lt;int\u0026gt; g[N]; int color[N]; bool bfs() { for(int i=1;i\u0026lt;=n;i++) //图不是一张连通图的时候需要查看每个节点 { if(color[i]) continue; queue\u0026lt;int\u0026gt; q; color[i] = 1; q.push(i); while(!q.empty()) { int t = q.front(); q.pop(); for(auto v : g[t]) { if(!color[v]) { color[v] = color[t]%2+1; q.push(v); } else if(color[v] == color[t]) return false; } } } return true; } 例题: P1330 封锁阳光大学\n判定二分图 + 求最小点覆盖\n本题要求用最少河蟹封锁所有道路且不冲突，可转化为二分图最小顶点覆盖问题。首先需判断图是否为二分图，若存在奇数环则输出 “Impossible”。若为二分图，根据二分图性质，最小顶点覆盖数为两部分节点数的较小值。具体步骤：用 BFS 染色法判定二分图，染色时记录两部分节点数，对每个连通块取较小部分节点数累加，即为最少河蟹数。\nSTD: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#34;\\n\u0026#34; #define int long long using namespace std; const int N = 1e5+10; int n,m; vector\u0026lt;int\u0026gt; g[N]; int color[N]; int tot1,tot2; bool bfs(int x) { queue\u0026lt;int\u0026gt; q; color[x] = 1; tot1 = 1; tot2 = 0; q.push(x); while(!q.empty()) { int t = q.front(); q.pop(); for(auto v : g[t]) { if(!color[v]) { color[v] = color[t]%2+1; color[v] == 1 ? tot1++ : tot2++; q.push(v); } else if(color[v] == color[t]) return false; } } return true; } int ans; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i=1;i\u0026lt;=m;i++) { int u,v;cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u].push_back(v); g[v].push_back(u); } for(int i=1;i\u0026lt;=n;i++) { if(color[i]) continue; if(!bfs(i)) { cout \u0026lt;\u0026lt; \u0026#34;Impossible\u0026#34; \u0026lt;\u0026lt; endl; return; } else ans += min(tot1,tot2); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; //cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } ","date":"2025-06-18T00:00:00Z","permalink":"https://zephyrbd.github.io/p/bipartitegraph/","title":"二分图问题（含P1330 封锁阳光大学 题解）"},{"content":"分层图（Dijkstra实现） 什么是分层图（Layered Graph）？ 分层图是一种通过构建多层图结构来处理 “状态转移” 的建模方式。具体来说，将原图复制为若干层（如 k 层），每层代表不同的状态（如允许 k 次边权修改、k 次路径变换等），层与层之间通过特定规则连边，从而将带约束的最短路问题转化为普通图的最短路问题。\n特点： 每层图的节点和边结构与原图相似，但层间边用于表示状态切换（如使用一次 “特殊操作” 后从第 i 层转移到第 i+1 层）。 可处理 “允许有限次修改边权”“不同路径代价差异” 等复杂约束。 应用场景： 例如，在交通网络中，允许最多 k 次换乘或走高速（需额外代价），求从起点到终点的最短路径，可通过分层图建模解决。 经典例题：P4568 [JLOI2011] 飞行路线 题解： 这里为了解释分层图，给出一张解释图：\n（使用 @EternalAlexander 这位dalao的OI Painter绘制）：\n于是我们可以得出：\n\u0026ldquo;我们可以考虑把图分成 $k+1$ 层，每往下一层，边权变成 $0$ 的边就增加 $1$ 条。编号为 $i$ 的点在第 $j$ 层的编号为 $i+j \\times n$（$0 \\leq i \u0026lt; n, 0 \\leq j \\leq k$）。 每一层都有同样的 $n$ 个点，$m$ 条边。 在层与层之间有单向边，边权为 $0$，且不能从下层到上层。 对于一条边权为 $w$ 的无向边 $u \\leftrightarrow v$，我们可以在第 $i=0 \\sim k$ 层连无向边 $u+i \\times n \\leftrightarrow v+i \\times n$，边权为 $w$，表示每一层里的 $u$ 和 $v$ 能互相到达，且花费的代价为 $w$。 紧接着，在第 $i-1$ 层和第 $i$ 层之间连两条边权为 $0$ 的有向边 $u+(i-1) \\times n \\rightarrow v+i \\times n$ 和 $v+(i-1) \\times n \\rightarrow u+i \\times n$，表示可以把边 $u \\rightarrow v$ 或 $v \\rightarrow u$ 的边权变成 $0$，然后到下一层的 $v$ 点或 $u$ 点。 建图后，$s$ 到 $t+k \\times n$ 的最短路即是用完 $k$ 次机会的最少花费。 最后可能没有用完 $k$ 次机会，所以到每层终点的最短路都有可能成为答案，取最小值即可。时间复杂度为 $O(mk \\log(nk))$。\u0026rdquo;\n——引用自洛谷题解 P4568 【[JLOI2011]飞行路线】\n但是在我们实现的时候可以有：\n\u0026ldquo;事实上，虽然样例可以用这种方法画图表示，但我们写代码的时候不一定要建这么多结点。只需要按照原始的输入建普通的图。考虑 多维状态表示（DP）。设 $dis_{i,j}​$表示当前从起点$ i $号结点，使用了$ j $次免费通行权限后的最短路径。显然，$dis $数组可以这么转移：\n$$ dis_{i,j} ​=min\\{min\\{dis_{from,j−1}\\},min\\{dis_{from,j​+w}\\} $$其中，$from$ 表示 $i$ 的父亲节点，$w $表示当前所走的边的边权。当$ j−1≥k $时，$dis_{from,j​} = ∞$。 事实上，这个 dp 就相当于对于每个结点的$ k+1 $个状态，想象成拆为$ k+1 $个不同的结点，每个结点之间可以相连，仿佛这张图一共有 k+1 层。 对于进行 Dijkstra 算法的过程，把$ done $数组也开成二维就好，每次入队的时候分别判断能否使用免费通行权限即可。最后统计答案的时候需要统计出到最后一个结点总共$ k+1 $种状态的最短距离。\u0026rdquo;\n——引用自洛谷题解 P4568 【[JLOI2011]飞行路线\n代码实现： 建$k$层图版本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#39;\\n\u0026#39; #define int long long using namespace std; const int N = 2e5+10; struct node { bool operator\u0026lt;(const node x) const { return w \u0026lt; x.w; } int v,w; }; vector\u0026lt;node\u0026gt; vt[N]; int n,m,k; int s,t; bool vis[N]; int dis[N]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for(int i=1;i\u0026lt;=m;i++) { int u,v,w;cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; vt[u].push_back({v,w}); vt[v].push_back({u,w}); for(int j=1;j\u0026lt;=k;j++) { vt[u+(j-1)*n].push_back({v+j*n,0}); vt[v+(j-1)*n].push_back({u+j*n,0}); vt[u+j*n].push_back({v+j*n,w}); vt[v+j*n].push_back({u+j*n,w}); } } priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;,greater\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt; pq; for(int i=0;i\u0026lt;=n*(k+5);i++) dis[i] = INT_MAX; dis[s] = 0; pq.push({0,s}); while(!pq.empty()) { auto nod = pq.top(); pq.pop(); int u = nod.second; if(vis[u]) continue; vis[u] = true; for(int i=0;i\u0026lt;(int)vt[u].size();i++) { auto [v,w] = vt[u][i]; if(dis[v] \u0026gt; dis[u] + w) { dis[v] = dis[u] + w; pq.push({dis[v],v}); } } } int ans = INT_MAX; for(int i=0;i\u0026lt;=k;i++) ans = min(ans,dis[t+i*n]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; //cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } 状态表示实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#39;\\n\u0026#39; #define int long long using namespace std; const int N = 2e5+10; struct node { bool operator\u0026lt;(const node x) const { return w \u0026gt; x.w; } int v,w,cnt; }; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vt[N]; int n,m,k; int s,t; bool vis[N][12]; int dis[N][12]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for(int i=1;i\u0026lt;=m;i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; vt[u].push_back({v,w}); vt[v].push_back({u,w}); } for(int i=0;i\u0026lt;n;i++) for(int j=0;j\u0026lt;=k;j++) dis[i][j] = INT_MAX,vis[i][j] = false; priority_queue\u0026lt;node\u0026gt; pq; dis[s][0] = 0; pq.push({s,0,0}); while(!pq.empty()) { auto [u,ns,cnt] = pq.top(); pq.pop(); if(vis[u][cnt]) continue; vis[u][cnt] = true; for(int i=0;i\u0026lt;(int)vt[u].size();i++) { auto [v,w] = vt[u][i]; if(cnt \u0026lt; k \u0026amp;\u0026amp; dis[v][cnt+1] \u0026gt; dis[u][cnt]) { dis[v][cnt+1] = dis[u][cnt]; pq.push({v,dis[v][cnt+1],cnt+1}); } if(dis[v][cnt] \u0026gt; dis[u][cnt] + w) { dis[v][cnt] = dis[u][cnt] + w; pq.push({v,dis[v][cnt],cnt}); } } } int ans = INT_MAX; for(int i=0;i\u0026lt;=k;i++) ans = min(ans,dis[t][i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; //cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } 例题: 小帅的车费 题目描述 小帅要去参加 ICPC 贵州省赛了，小帅的学校在 $s$ 地，省赛举办地为 $t$ 地，为了方便报销，小帅打算坐车前往。已知贵州的公交线路上有 $n$ 个站点，编号从 $0 \\sim n - 1$，站点间为双向道路，每段双向道路都有对应的价格 $x$，且暑假期间公交公司给予小帅 $k$ 张优惠券，对应的折扣为 $p_1, p_2, \\dots, p_k$ 。由于优惠券上有日期限制，小帅为了尽快用掉快过期的券，他会依次使用这些优惠券。每条路只能最多使用一次优惠券，当小帅对某一路段用第 $i$ 张优惠券时，该路段的价格 $x$ 将会变成：\n$$ x = \\left\\lfloor \\frac{x \\cdot p_i}{100} \\right\\rfloor $$请问小帅最后能否到达 $t$ 地，并计算需要的最少车费是多少？\n输入格式 第一行三个整数 $n, m, k$（$1 \\leq n, m \\leq 10^5$, $0 \\leq k \\leq 10$）分别表示城市数，双向道路数，优惠券个数； 第二行 $k$ 个整数 $p_1, p_2, \\dots, p_k$（$0 \\leq p_i \\leq 99$）； 第三行两个整数表示 $s, t$（$0 \\leq s, t \\leq n - 1$）表示出发地和到达地； 最后 $m$ 行每行 3 个整数 $a, b, c$（$0 \\leq a, b \\leq n - 1$, $1 \\leq c \\leq 10^9$）表示有一条道路使站点 $a, b$ 相互连通，票价为 $c$； 本题可能存在重边和自环。\n输出格式 如果可以到达目的地，请输出一个整数表示所需要的最少车费；否则输出 Impossible。\nInput: 1 2 3 4 5 6 7 8 9 5 6 1 10 0 4 0 1 500 1 2 500 2 3 500 3 4 500 2 3 300 0 2 100 Output: 1 450 题解: 本题为最短路径变种问题，核心是在传统Dijkstra算法基础上，结合优惠券的顺序使用规则进行状态扩展。 关键思路：定义 dis[u][cnt] 表示到达节点 u 时已使用 cnt 张优惠券的最小费用。通过优先队列（小根堆）维护当前最小费用状态，每次取出最优状态后，分两种情况扩展：\n不使用优惠券：直接累加当前路段原价到邻接节点； 使用下一张优惠券（若未用完）：按顺序使用第 cnt+1 张券，路段费用变为 x*p[cnt+1]/100（向下取整），更新对应状态。 最终遍历所有可能的优惠券使用数量（0~k），取到达终点 t 的最小费用。若所有状态均不可达，输出 Impossible，否则输出最小费用。 算法通过状态扩展覆盖所有可能的优惠券使用组合，确保找到全局最优解。 本题卡常，不能建k层图。 STD: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#39;\\n\u0026#39; #define int long long #define INF 1e18 using namespace std; const int N = 1e5+10; struct node { bool operator\u0026lt;(const node x)const { return w \u0026gt; x.w; } int v,w,cnt; }; int n,m,k; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; vt[N]; int dis[N][11]; bool vis[N][11]; int s,t; int p[110]; void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; for(int i=1;i\u0026lt;=k;i++) cin \u0026gt;\u0026gt; p[i]; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; for(int i=1;i\u0026lt;=m;i++) { int u,v,w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; vt[u].push_back({v,w}); vt[v].push_back({u,w}); } priority_queue\u0026lt;node\u0026gt; pq; for(int i=0;i\u0026lt;=n;i++) for(int j=0;j\u0026lt;=k;j++) dis[i][j] = INF; dis[s][0] = 0; pq.push({s,0,0}); while(!pq.empty()) { auto [u,ns,cnt] = pq.top(); pq.pop(); if(vis[u][cnt]) continue; vis[u][cnt] = true; for(int i=0;i\u0026lt;(int)vt[u].size();i++) { auto [v,w] = vt[u][i]; if(dis[v][cnt] \u0026gt; dis[u][cnt] + w) { dis[v][cnt] = dis[u][cnt] + w; pq.push({v,dis[v][cnt],cnt}); } if(cnt \u0026lt; k) { int ndis = w * p[cnt + 1] / 100; if(dis[v][cnt+1] \u0026gt; dis[u][cnt] + ndis) { dis[v][cnt+1] = dis[u][cnt] + ndis; pq.push({v,dis[v][cnt+1],cnt+1}); } } } } int ans = INF; for (int i = 0; i \u0026lt;= k; i++) ans = min(ans, dis[t][i]); if (ans == INF) cout \u0026lt;\u0026lt; \u0026#34;Impossible\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; //cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } ","date":"2025-06-18T00:00:00Z","permalink":"https://zephyrbd.github.io/p/layeredgraph/","title":"分层图（含P4568 飞行路线题解）"},{"content":"树的中心点问题 常见套路: N-1条公路连接着N个城市，从每个城市出发都可以通过公路到达其它任意的城市。每个城市里面都有一定数量的居民，但是数量并不一定相等，每条公路的长度也不一定相等。X公司（或者是政府）决定在某一个城市建立一个医院/酒厂/游乐场……，问：将它建在哪里，可以使得所有的居民移动到那里的总耗费最小？这种题目都是本题的“变型”，一般称为“树的中心点问题”。\n例题： P1364 医院设置 - 洛谷\nDP状态转移解释: dis[e[i].to]表示子节点作为医院时的距离和 转移公式：dis[子节点] = dis[父节点] + pre[1] - 2*pre[子节点] 其中pre[1]是整棵树的总入口数，这个公式的含义是： 当医院从父节点移动到子节点时，子树内的节点到医院的距离减少了，子树外的节点到医院的距离增加了 距离和的变化量为：子树外的人口数 - 子树内的人口数 = (pre [1]-pre [子节点]) - pre [子节点] = pre [1]-2*pre [子节点] STD: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;bits/stdc++.h\u0026gt; #define endl \u0026#34;\\n\u0026#34; #define int long long using namespace std; const int N = 2e5+10; int n; vector\u0026lt;int\u0026gt; g[N]; int vals[N]; int dep[N]; int len[N]; int dis[N]; int ans; void dfs(int x,int fa) { dep[x] = dep[fa]+1; for(auto t : g[x]) { if(t==fa) continue; dfs(t,x); len[x] += len[t]; } } void dp(int x,int fa) { for(auto t : g[x]) { if(t==fa) continue; dis[t] = dis[x]+len[1]-len[t]-len[t]; if(dis[t] \u0026lt; ans) ans = dis[t]; dp(t,x); } } void solve() { cin \u0026gt;\u0026gt; n; for(int i=1;i\u0026lt;=n;i++) { int u,v; cin \u0026gt;\u0026gt; vals[i] \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; len[i] = vals[i]; if(u) { g[i].push_back(u); g[u].push_back(i); } if(v) { g[i].push_back(v); g[v].push_back(i); } } dfs(1,0); for(int i=1;i\u0026lt;=n;i++) dis[1] += (dep[i]-1)*vals[i]; ans = dis[1]; dp(1,0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; //cin \u0026gt;\u0026gt; _; while(_--) { solve(); } return 0; } ","date":"2025-06-18T00:00:00Z","permalink":"https://zephyrbd.github.io/p/thecenterofatree/","title":"树的中心点问题（含P1364 医院设置 题解）"},{"content":"抽屉原理 定义 抽屉原理，亦称鸽巢原理（The Pigeonhole Principle）。\n它常被用于证明存在性证明和求最坏情况下的解。\n简单情况 将 $n+1$ 个物体，划分为 $n$ 组，那么有至少一组有两个（或以上）的物体。\n这个定理看起来比较显然，证明方法考虑反证法：假如每个分组有至多 $1$ 个物体，那么最多有 $1\\times n$ 个物体，而实际上有 $n+1$ 个物体，矛盾。\n实际解释 对于需要配对的物品 $ n $ ，我们可以根据需要把它分为多个盒子（考虑最坏情况下的盒子数目），先按照条件向盒子中添加上需要配对的物品之一，然后对于剩下的物品，我们考虑最坏条件下需要拿到几个东西才能装满一个盒子，又有多少个盒子装不满。\n例题 B. Wonderful Gloves - Codeforces\n题解 对于一种颜色的手套，我们最多有可能配对出$mx_i = max(Left[i],Right[i])$组手套，即我们开了$mx_i$个盒子，每个盒子先放入一只左或者右手套，然后对于每种颜色的盒子，我们最多能向$mi_i = min(Left[i],Right[i])$个盒子中放入缺少的另一个（即配对）。考虑到最坏的情况，即一开始每次拿出的手套每个都是不配对的，那最多拿到$\\sum_{i=0}^nmx_i$个能是单的，考虑配对的时候，最坏情况是前$k-1$种颜色的单个手套被尽可能的全部被配对（即先降序排序$mi_i$，然后拿出前$k-1$个数列元素），对于最后一种颜色$k$，我们无论再拿出什么颜色的手套，此时一定能配对一个，则配对了$k$种颜色的手套，每个颜色至少拿一个的最坏情况（即答案）。\nC++实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;bits/stdc++.h\u0026gt; #define int long long #define endl \u0026#39;\\n\u0026#39; using namespace std; const int N = 1e6 + 10; //100005 int l[N],r[N],a[N]; void solve() { int n,k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for(int i=1;i\u0026lt;=n;i++) cin \u0026gt;\u0026gt; l[i]; for(int i=1;i\u0026lt;=n;i++) cin \u0026gt;\u0026gt; r[i]; int ans = 0; for(int i=1;i\u0026lt;=n;i++) ans += max(l[i],r[i]),a[i] = min(l[i],r[i]); sort(a+1,a+1+n,greater\u0026lt;\u0026gt;()); for(int i=1;i\u0026lt;=k-1;i++) ans += a[i]; cout \u0026lt;\u0026lt; ans + 1 \u0026lt;\u0026lt; endl; } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; cin \u0026gt;\u0026gt; _ ; while(_--) { solve(); } return 0; } ","date":"2025-05-26T00:00:00Z","permalink":"https://zephyrbd.github.io/p/thepigeonholeprinciple/","title":"抽屉原理（含Wonderful Gloves题解）"},{"content":"（板子）Clion中的Qt框架的CMake配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 cmake_minimum_required(VERSION 3.29) #必改：项目名 project(YOUR_PROJECT_NAME) set(CMAKE_CXX_STANDARD 17) set(CMAKE_AUTOMOC ON) set(CMAKE_AUTORCC ON) set(CMAKE_AUTOUIC ON) #必改：Qt库的位置 set(CMAKE_PREFIX_PATH \u0026#34;E:/Qt/6.8.0/mingw_64\u0026#34;) find_package(Qt6 COMPONENTS Core Gui Widgets Network #项目的Qt库 #额外需要的也要加在这里 REQUIRED) add_executable(${PROJECT_NAME} main.cpp #必改：项目涉及到的文件写在这里 ) target_link_libraries(RandomSelector Qt::Core Qt::Gui Qt::Widgets Qt::Network #项目涉及到的Qt库 ) if (WIN32 AND NOT DEFINED CMAKE_TOOLCHAIN_FILE) set(DEBUG_SUFFIX) if (MSVC AND CMAKE_BUILD_TYPE MATCHES \u0026#34;Debug\u0026#34;) set(DEBUG_SUFFIX \u0026#34;\u0026#34;) endif () set(QT_INSTALL_PATH \u0026#34;${CMAKE_PREFIX_PATH}\u0026#34;) if (NOT EXISTS \u0026#34;${QT_INSTALL_PATH}/bin\u0026#34;) set(QT_INSTALL_PATH \u0026#34;${QT_INSTALL_PATH}/..\u0026#34;) if (NOT EXISTS \u0026#34;${QT_INSTALL_PATH}/bin\u0026#34;) set(QT_INSTALL_PATH \u0026#34;${QT_INSTALL_PATH}/..\u0026#34;) endif () endif () if (EXISTS \u0026#34;${QT_INSTALL_PATH}/plugins/platforms/qwindows${DEBUG_SUFFIX}.dll\u0026#34;) add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E make_directory \u0026#34;$\u0026lt;TARGET_FILE_DIR:${PROJECT_NAME}\u0026gt;/plugins/platforms/\u0026#34;) add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy \u0026#34;${QT_INSTALL_PATH}/plugins/platforms/qwindows${DEBUG_SUFFIX}.dll\u0026#34; \u0026#34;$\u0026lt;TARGET_FILE_DIR:${PROJECT_NAME}\u0026gt;/plugins/platforms/\u0026#34;) endif () #添加Qt适配Windows窗口组件的dll库，Qt5名字和这里的不一样 if (EXISTS \u0026#34;${QT_INSTALL_PATH}/plugins/styles/qmodernwindowsstyle${DEBUG_SUFFIX}.dll\u0026#34;) add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E make_directory \u0026#34;$\u0026lt;TARGET_FILE_DIR:${PROJECT_NAME}\u0026gt;/plugins/styles/\u0026#34;) add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy \u0026#34;${QT_INSTALL_PATH}/plugins/styles/qmodernwindowsstyle${DEBUG_SUFFIX}.dll\u0026#34; \u0026#34;$\u0026lt;TARGET_FILE_DIR:${PROJECT_NAME}\u0026gt;/plugins/styles/\u0026#34;) endif () # 添加项目需要的Qt库 foreach (QT_LIB Core Gui Widgets Network) add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy \u0026#34;${QT_INSTALL_PATH}/bin/Qt6${QT_LIB}${DEBUG_SUFFIX}.dll\u0026#34; \u0026#34;$\u0026lt;TARGET_FILE_DIR:${PROJECT_NAME}\u0026gt;\u0026#34;) endforeach (QT_LIB) # 复制 MinGW 运行时库 set(MINGW_RUNTIME_LIBS \u0026#34;libstdc++-6.dll\u0026#34; \u0026#34;libgcc_s_seh-1.dll\u0026#34; \u0026#34;libwinpthread-1.dll\u0026#34;) foreach (LIB ${MINGW_RUNTIME_LIBS}) if (EXISTS \u0026#34;${QT_INSTALL_PATH}/bin/${LIB}\u0026#34;) add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy \u0026#34;${QT_INSTALL_PATH}/bin/${LIB}\u0026#34; \u0026#34;$\u0026lt;TARGET_FILE_DIR:${PROJECT_NAME}\u0026gt;\u0026#34;) endif () endforeach () endif () ","date":"2025-05-02T00:00:00Z","permalink":"https://zephyrbd.github.io/p/qtwithclion/","title":"（板子）Clion中的Qt框架的CMake配置"},{"content":"线段树 线段树：线段树是一种二叉树数据结构。其每个节点代表一个区间，根节点代表整个区间，叶子节点代表最小子区间，是平衡二叉树，高度为$(O(log n))$。它能高效进行区间查询、单点修改和区间修改等操作，操作时间复杂度一般为$ (O(log n))$，常用于数组统计、区间更新与查询等场景，可提高相关算法的时间和空间复杂度。\n建树（分治思想） 通过观察，发现我们如果为每个节点补足NULL，它形成了一个完全二叉树，于是我们有以下的规律：\n$$ parent_i = \\left\\lfloor \\frac{i}{2} \\right\\rfloor $$$$ left_i = 2 * i , right_i = 2 * i + 1 $$每个节点存储下各自对应区间的最大值，于是我们得到：\n区间查询 假设我们要查找区间$ [2,3] $的最大值，我们先看到root节点，发现$[2,3]$与$[1,6]$并不完全匹配，所以我们继续向下遍历，当到达节点4的时候，发现$[2,3]$与其左右孩子均有交集，于是我们兵分两路，分别以此类推的去找$[2,2]$和$[3,3]$的最大值。\n最后找到5和9节点，答案就为$max(tree[5],tree[9])$\n单点更新 假设我们尝试把原数组的第二个数字更新为6，我们一样按照区间查询的思想找到$[2,2]$这个节点，并依次向上更新整个线段树。\n区间更新 定义：为一个区间内的所有值加上一个常数。\n为了使得时间复杂度保持在$O(logn)$，于是我们引入一个新的概念——懒标记，由于最初没有任何区间更新，于是我们初始化所有懒标记为0。\n我们尝试令区间$[4,6]$的每个元素+1，还是按照区间查询的思想找到符合的节点，这里我们找到节点3，发现它与我们要更新的节点完全匹配，于是我们把节点3的值加上1，为了优化性能，我们在这里偷个懒——把更新请求存储到节点3的lazy标记上，如下图所示：\n所以懒标记的作用就是允许我们延迟更新操作，只在有需求的时才真正执行。\n最后别忘了依次向上更新数组。\n我们再来假设给$[4,5]$的每个元素+1，依旧先找到匹配的节点。\n当到达节点3的时候，我们发现区间并不完全匹配，于是在继续向下更新时，我们要先检查节点3的lazy标记，由于其不为0，说明之前有偷懒未执行的更新操作，所以此时要对lazy标记进行“下发”处理：将其标记的值1传递给其左右孩子节点6和7，更新6,7的值和懒标记，同时归零节点3的懒标记，如下图所示：\n接着遍历，我们来到节点6，发现此时节点6与查询区间$[4,5]$完全匹配，于是我们更新节点6的值，并且在节点6的懒标记上加上我们的更新请求，如图所示： 最后还是别忘了依次向上更新数组。\n懒标记对区间查询和单点更新的影响 由于懒标记的特性，所以在进行区间查询或单点更新的时候，如果遇到某个节点有懒标记，我们必须先对lazy标记进行“下发”处理，然后再继续查询。\n当然，单点更新还是别忘了依次向上更新数组。\n代码实现 我们先定义一个node节点：\n1 2 3 struct node { int data, lazy = 0; }; 接下来我们实现了线段树的构建函数build：\n1 2 3 4 5 6 7 8 9 10 void build(const vector\u0026lt;int\u0026gt; \u0026amp;data, vector\u0026lt;node\u0026gt; \u0026amp;tree, int rt, int left, int right) { if (left == right) { tree[rt].data = data[left];//叶子节点 return; } int mid = left + (right - left) / 2; build(data, tree, 2*rt, left, mid);//递归构建左子树 build(data, tree, 2*rt + 1, mid + 1, right);//递归构建右子树 tree[rt].data = max(tree[2 * rt].data, tree[2 * rt + 1].data);//更新当前节点的值 } 对于懒标记的处理pushDown：\n1 2 3 4 5 6 7 8 9 10 11 12 void pushDown(vector\u0026lt;node\u0026gt; \u0026amp;tree, int rt) { if(tree[rt].lazy != 0) { //更新左子树 tree[2 * rt].data += tree[rt].lazy; tree[2 * rt].lazy += tree[rt].lazy; //更新右子树 tree[2 * rt + 1].data += tree[rt].lazy; tree[2 * rt + 1].lazy += tree[rt].lazy; //清空当前节点的懒标记 tree[rt].lazy = 0; } } 查询函数query:\n1 2 3 4 5 6 7 8 9 10 11 12 13 int query(vector\u0026lt;node\u0026gt; \u0026amp;tree, int rt, int left,int right,int ql,int qr) { if (ql \u0026gt; right || qr \u0026lt; left) { return INT_MIN; // 若区间无交集，返回最小值，表明该区间对结果无贡献 } if (ql \u0026lt;= left \u0026amp;\u0026amp; qr \u0026gt;= right) { return tree[rt].data; // 若完全包含，直接返回当前节点的值 } int mid = left + (right - left) / 2; pushDown(tree, rt); // 若当前节点有延迟标记，将其下推到子节点 int leftMax = query(tree, 2*rt, left, mid, ql, qr); // 递归查询左子树 int rightMax = query(tree, 2*rt+1, mid+1, right, ql, qr); // 递归查询右子树 return max(leftMax, rightMax); } 单点更新函数update：\n1 2 3 4 5 6 7 8 9 10 11 12 void update(vector\u0026lt;node\u0026gt; \u0026amp;tree, int rt, int left, int right, int idx, int value) { if(left == right){ tree[rt].data = value; tree[rt].lazy = 0;//找到目标节点，更新值 return; } int mid = left + (right - left) / 2; pushDown(tree, rt);//处理懒标记 if(idx \u0026lt;= mid) update(tree, 2*rt, left, mid, idx, value); else update(tree, 2*rt+1, mid+1, right, idx, value); tree[rt].data = max(tree[rt*2].data, tree[rt*2+1].data); } 区间更新函数updateRange：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void updateRange(vector\u0026lt;node\u0026gt; \u0026amp;tree, int rt, int left, int right, int ul, int ur, int value){ if(ul \u0026gt; right || ur \u0026lt; left) return; //区间无交集，直接返回 if(ul \u0026lt;= left \u0026amp;\u0026amp; ur\u0026gt;= right) { tree[rt].data += value; //更新当前节点的值 tree[rt].lazy += value; //设置懒标记 return; } int mid = left + (right - left) / 2; pushDown(tree, rt); //处理懒标记 updateRange(tree, 2*rt, left, mid, ul, ur, value); //更新左子树 updateRange(tree, 2*rt+1, mid+1, right, ul, ur, value); //更新右子树 tree[rt].data = max(tree[rt*2].data, tree[rt*2+1].data); //更新当前节点的值 } 最后强调：为了避免越界问题，线段树的大小通常会初始化为原始区间大小的4倍\nclass模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 struct node { int data, lazy = 0; }; class SegTree { public: int n, root, L, R; vector\u0026lt;int\u0026gt; data; vector\u0026lt;node\u0026gt; tree; SegTree(int _n, int _rt, int _L, int _R) : n(_n), root(_rt), L(_L), R(_R), data(n+1), tree(4*n) {} // 对外接口 void build() { build(root, L, R); } void update(int idx, int value) { update(root, L, R, idx, value); } void updateRange(int ul, int ur, int value) { updateRange(root, L, R, ul, ur, value); } int query(int ql, int qr) { return query(root, L, R, ql, qr); } private: void build(int rt, int left, int right) { if (left == right) { tree[rt].data = data[left];//叶子节点 return; } int mid = left + (right - left) / 2; build(2*rt, left, mid);//递归构建左子树 build(2*rt + 1, mid + 1, right);//递归构建右子树 tree[rt].data = max(tree[2 * rt].data, tree[2 * rt + 1].data);//更新当前节点的值 } void pushDown(int rt) { if(tree[rt].lazy != 0) { //更新左子树 tree[2 * rt].data += tree[rt].lazy; tree[2 * rt].lazy += tree[rt].lazy; //更新右子树 tree[2 * rt + 1].data += tree[rt].lazy; tree[2 * rt + 1].lazy += tree[rt].lazy; //清空当前节点的懒标记 tree[rt].lazy = 0; } } int query(int rt,int left,int right,int ql,int qr) { if (ql \u0026gt; right || qr \u0026lt; left) { return INT_MIN; // 若区间无交集，返回最小值，表明该区间对结果无贡献 } if (ql \u0026lt;= left \u0026amp;\u0026amp; qr \u0026gt;= right) { return tree[rt].data; // 若完全包含，直接返回当前节点的值 } int mid = left + (right - left) / 2; pushDown(rt); // 若当前节点有延迟标记，将其下推到子节点 int leftMax = query(2*rt, left, mid, ql, qr); // 递归查询左子树 int rightMax = query(2*rt+1, mid+1, right, ql, qr); // 递归查询右子树 return max(leftMax, rightMax); } void update(int rt, int left, int right, int idx, int value) { if(left == right){ tree[rt].data = value; tree[rt].lazy = 0;//找到目标节点，更新值 return; } int mid = left + (right - left) / 2; pushDown(rt);//处理懒标记 if(idx \u0026lt;= mid) update(2*rt, left, mid, idx, value); else update(2*rt+1, mid+1, right, idx, value); tree[rt].data = max(tree[rt*2].data, tree[rt*2+1].data); } void updateRange(int rt, int left, int right, int ul, int ur, int value){ if(ul \u0026gt; right || ur \u0026lt; left) return; //区间无交集，直接返回 if(ul \u0026lt;= left \u0026amp;\u0026amp; ur\u0026gt;= right) { tree[rt].data += value; //更新当前节点的值 tree[rt].lazy += value; //设置懒标记 return; } int mid = left + (right - left) / 2; pushDown(rt); //处理懒标记 updateRange(2*rt, left, mid, ul, ur, value); //更新左子树 updateRange(2*rt+1, mid+1, right, ul, ur, value); //更新右子树 tree[rt].data = max(tree[rt*2].data, tree[rt*2+1].data); //更新当前节点的值 } }; ","date":"2025-04-23T00:00:00Z","permalink":"https://zephyrbd.github.io/p/segmenttree/","title":"线段树"},{"content":"比赛常用软件测试流程 适用于蓝桥杯，天梯赛，睿抗。\nDev C++ 打开桌面的Dev C++后按照图片新建源文件 设置编译标准，按照如下两张图片就可以，两个c++11标准选择一个 完成创建和编译标准设置后执行如下代码，测试C++11标准能否使用。点击图片鼠标处运行，不报错就没问题。 1 2 3 4 5 6 7 8 9 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int a[5]={1,2,3,4,5}; for(auto it:a) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } Code Blocks 打开Code Blocks后按照如下图片创建文件 点击下图的 \u0026hellip; 选择创建文件位置 创建文件后执行如下代码 1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ cout\u0026lt;\u0026lt;\u0026#34;123\u0026#34;; return 0; } 4.点击箭头所在处运行代码\n若点击后无反应，按照如下图片更改编译器设置。\nMinG64一般都在DevCpp文件夹中，DevCpp文件夹的路径一般都是这个。\nEclipse 要保证不同版本的eclipse使用workplace路径不一样，其他流程都相同，按照如下图片创建java文件 关闭welcome 项目名随便写，点finish 对项目里的src右键 类名随便写\n创建类后在自动生成的类定义里面填下面的代码 1 2 3 public static void main(String[] args){ System.out.print(\u0026#34;123\u0026#34;); } 按图运行 IDEA 按图创建项目和java文件 然后会自动生成一个java文件，直接运行。 没报错就可以了。\nPyCharm 1.按照图片创建项目和py文件\n文件名随便取 3.按图运行代码\n1 print(123) Python 3.10 点开后输入\n1 print(123) 有结果就可以\nOMS 双击桌面的oms 等待二维码跳出就可以。\n收尾 测试完之后需要将生成的文件和项目删除，一般在c盘的用户中的各种project文件夹，workplace文件夹，d盘中的workplace文件夹，和桌面上。\n","date":"2025-04-20T00:00:00Z","permalink":"https://zephyrbd.github.io/p/idetesting/","title":"比赛常用软件测试流程"},{"content":"倍增算法（含L3-1 银白之森题解） 本文背景 天梯赛后被建议来吃吃“银白之森”这坨，吃完了认为确实是一坨，故写本文来介绍一下这个题所涉及到的倍增算法。\n朴素倍增 对于这样一个问题：\n从0出发，到7格外的位置上，如何快速转移你的位置。\n最简单最暴力的算法就是一格一格走（但是给到 $ 1≤k≤10^{12} $ 你不就炸了吗？）。\n于是看这个数的二进制，发现：\n任何一个数都可以用$ n $个$ 2^k $的和来表示。\n则对于这样一个图：\n我们发现从0到7需要跨越 $ 7_{10} (111_2) $格，即 $ 7 = 2^0 + 2^1 + 2^2 $，于是我们建立一个状态表示数组$ f $，使得 $ f[i][j] $ 表示从1出发，跨越$ 2^{j} $ 步所到达的地方。\n以这个图为例：我们依次经过$ f[0][0]=1,f[1][1]=3,f[3][2]=7 $到达了第7格。\n这时有人发现：\n$$ 2^{n} = 2^{n-1}\\times2 = 2^{n-1}+2^{n-1} $$这样从$i$出发，走$2^{j}$格，就可以看成从$i$出发，走$2^{j-1}$格后到达$i+A$，再走$2^{j-1}$格到达目的地，递推关系如下：\n$$ f[i][j] = f[f[i][j-1]][j-1] $$所以，如果我们预先处理好一个这样的状态表示数组$ f $，那查询的时候时间复杂度会大大降低，该算法的时间复杂度为$ O(n \\log k) $。\nEg：L3-1 银白之森 作者：Chocola 题目描述 ： 在不知名的银白之森，共有 $n$ 个节点。\n每个节点处，生活着一名魔法师。在每个节点，有一条通向其他节点的单向道路。\n不知道该说运气好还是不好，你被一阵神秘的力量所影响，落在了某个节点上。接下来你可以沿着这些单向道路移动 $k$ 次。每利用单向道路移动到一个节点，这个节点处的魔法师会为你进行一次赐福，获得等于节点编号数量的命定之缘。（例如，当节点编号为 3 时，经过这个节点可以获得 3 个命定之缘）。\n需要注意的是，反复经过同一个节点时，可以重复获得命定之缘。\n非常幸运，你提前掌握了整个银白之森的道路图。但同时非常不幸，你会被神秘的力量丢到某个随机的节点上 $q$ 次。那么，聪明如你，能求出来这 $q$ 次移动分别能获得多少命定之缘吗？\n输入格式 ： 一行两个正整数 $ n $ 和 $ q $ ，表示银白之森总共有 $ n $ 个节点，编号为 1 到 $ n $ 。总共会有 $ q $ 次神秘力量。 $(1≤n,q≤100,000 )$\n接下来一行 $ n $ 个整数，第 $ i $ 个整数表示节点 $ i $ 处的单向道路通向哪个节点。（保证范围在 $ [1,n] $ 内，单向道路可以指向自己）\n接下来 $ q $ 行，每行两个整数 $ x,k $ ，表示你该次神秘力量影响下落在了点$ x $ 处，你可以沿着单向道路移动 $ k $ 次获得赐福。$(1≤x≤n ，1≤k≤10^{12})$\n输出格式 ： 共 $ q $ 行，每行表示一次神秘力量影响下，你通过赐福获得的命定之缘的数量。\n输入样例：\n1 2 3 4 6 2 2 3 1 5 6 6 1 5 4 5 输出样例：\n1 2 11 29 样例解释\n第一次移动路径：1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 3\n获得的命定之缘共计2 + 3 + 1 + 2 + 3 = 11\n第二次移动路径：4 -\u0026gt; 5 -\u0026gt; 6 -\u0026gt; 6 -\u0026gt; 6 -\u0026gt; 6\n获得的命定之缘共计5 + 6 + 6 + 6 + 6 = 29\n分析 由于每个点只有一个固定的出边，所以每个点走 步后获得的命定之缘数量以及走到了哪一个点是可以确定的。\n我们采用倍增的方式去维护每个点走 $ 2^{0},2^{1},2^{2},2^{3},2^{4}\u0026hellip;2^{50} $ 后到达的位置以及获得的命定之缘的数量，每次询问时，将$ k $拆解成二进制数，快速跳转并计算贡献即可。\n代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026#34;bits/stdc++.h\u0026#34; #define int long long using namespace std; const int N = 1e5 + 10; //100005 int dp[N][65]; int sum[N][65]; void solve() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; dp[i][0]; sum[i][0] = dp[i][0]; } for (int j = 1; j \u0026lt;= 63; j++) { for (int i = 1; i \u0026lt;= n; i++) { dp[i][j] = dp[dp[i][j - 1]][j - 1]; //计算每个点出发走不同的2^j步可能到达的点 sum[i][j] = sum[i][j - 1] + sum[dp[i][j - 1]][j - 1]; //记录走2^j的步到这的命定之缘的和 } } while(q --) { long long x, k, ans = 0; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; k; for(int i=63;i\u0026gt;=0;i--) { if(k \u0026gt;\u0026gt; i \u0026amp; 1) //依次从高往低取k的二进制位 { ans += sum[x][i]; x = dp[x][i]; k -= (1ll \u0026lt;\u0026lt; i); //把1的二进制左移，在k上减去此次移动的步数 } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; // cin \u0026gt;\u0026gt; _ ; while(_--) { solve(); } return 0; } ","date":"2025-03-28T00:00:00Z","permalink":"https://zephyrbd.github.io/p/multiply/","title":"倍增算法（含L3-1 银白之森题解）"},{"content":"图的存储：链式前向星 本文背景 在解决倍增算法时发现该算法主要用于解决LCA（最近公共祖先）问题，于是转来看了看，看到了一种新的图存储方式（布什戈门，你还有啊！！），于是来写写这个B新存储方式：链式前向星。\n头插存储法（链式前向星） 概念 链式前向星结合了链表和数组的特点，其核心思想是通过数组模拟链表来存储图的边信息。它用一个数组 head 来记录每个顶点的第一条边的编号，同时用一个结构体数组 edge 来存储每条边的具体信息，包括边的终点和下一条边的编号。\nedge数组 对于一个图：\n我们看到1到2的这条边，发现边的信息有：起点（from），权值（wealth），终点（to），于是我们有结构体如下：\n1 2 3 4 struct node { int fr,w,to; }; 这是最直观的想法，但是我们发现如果真的这样存储的话，所有的信息会非常散乱，即一个点的边的信息的存储完全由输入的顺序决定，最坏情况可能就是有两个信息在输入开头和结尾，这显然会对遍历带来麻烦，于是我们引入了head数组。\nhead数组 如果我们想把一个点的所有边的数据整合一下的话，从物理层面上来说是把这些数据放到一起，但是对于内存这种奇葩的东西（整理过的都知道好）我们还是用一个结构分别记录每个点在edge数组中的位置吧。\n但聪明的你很快又发现：这不又是一个图了吗？（bushi），但很快你就发现，我们可以用链表（和C语言课上学的那种不完全一样）来打败这么多个图，即$ head[x] $表示输入流中$x$节点的最后一条边所在edge数组中的位置。\n这时候就有观众要问了：煮波煮波，head数组固然很强，那我们有没有找到输入流中$x$节点的非最后一条边所在edge数组中的位置的方法呢？\n有的兄弟，有的。\n我们只需要在node中加入一个新的量nxt去指向上一个节点的位置（链表bushi），而$ from $ 这个数据则体现在了head的下标中。\n综上所述，我们对node的定义如下：\n1 2 3 4 struct node { int to,w,nxt; }; 对这个例子，我们可以形象化的看到我们的数据结构如下： 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct node { int nxt,w,to; }; int head[N]; node edge[N]; int cnt; void add_edge(int from,int w,int to) { //这里以双向图为例 //先更新cnt是因为不想出现0这个点 edge[++cnt].nxt = head[from]; //指向from这个点的上一次输入进来边的信息的位置（edge） edge[cnt].to = to; edge[cnt].w = w; //from指向的点to和边权 head[from] = cnt; //更新head中from这个点的记录的最后一个点（edge）的信息 //反向边同理 edge[++cnt].nxt = head[to]; edge[cnt].to = from; edge[cnt].w = w; head[to] = cnt; } 视频讲解 Eg：P3379 【模板】最近公共祖先（LCA） 前置知识点 倍增算法（含L3-1 银白之森题解）\n思路 我们现尽可能让深度更深的节点（设为$x$）尽量的大的跳，不断减少跳的次数，直到跳不下去为止，然后我们来看$x$和$y$是否跳到了同一个节点，是，找到了LCA，直接返回；否就$x$和$y$一起接着跳，直到找到LCA为止。\n代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026#34;bits/stdc++.h\u0026#34; #define int long long using namespace std; const int N = 1e6 + 10; //100005 struct node { int nxt,to; }; int head[N],dep[N],f[N][25]; node edge[N]; int n,m,s; int cnt; void add_edge(int from,int to) { //双向图 edge[++cnt].nxt = head[from]; edge[cnt].to = to; head[from] = cnt; edge[++cnt].nxt = head[to]; edge[cnt].to = from; head[to] = cnt; } void dfs(int v,int fa) { dep[v]=dep[fa]+1; //更新该点的深度 for(int i=1;(1\u0026lt;\u0026lt;i)\u0026lt;=dep[v];i++) f[v][i] = f[f[v][i-1]][i-1]; //预处理这个点跳2^i次方到的点 for(int i=head[v];i;i=edge[i].nxt) { //递归dfs int p = edge[i].to; if(p!=fa) { f[p][0] = v; dfs(p,v); } } } int lca(int x,int y) { if(dep[x]\u0026lt;dep[y]) swap(x,y); //这一步是为了处理深的那个点 for(int i=20;i\u0026gt;=0;i--) //找这个点跳2^i次方到的点（假设最大是2^20） { if(dep[f[x][i]]\u0026gt;=dep[y]) x=f[x][i]; //意思是先跳到最远，然后有近的就退 if(x==y) return x; //是，那么return } //否就x和y一起接着跳，直到跳到了x,y不是一个祖先了 for(int i=20;i\u0026gt;=0;i--) { if(f[x][i]!=f[y][i]) { x = f[x][i]; y = f[y][i]; } } //那么x或y任意一个往上走2^0（即1）就到了LCA return f[x][0]; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; for(int i=1;i\u0026lt;=n-1;i++) { int x,y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; add_edge(x,y); } dfs(s,0); for(int i=1;i\u0026lt;=m;i++) { int a,b;cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; lca(a,b) \u0026lt;\u0026lt; endl; } } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; // cin \u0026gt;\u0026gt; _ ; while(_--) { solve(); } return 0; } ","date":"2025-03-28T00:00:00Z","permalink":"https://zephyrbd.github.io/p/linkedforwardstar/","title":"图的存储：链式前向星"},{"content":"树状数组（含Rotated Inversions题解） 本文背景 3.13 在解决 “F - Rotated Inversions”（逆序对问题）时，偶遇TLE强如怪物，拼尽归并排序无法战胜（实际上是我这蒟蒻写错了归并排序的位置导致的）。这道题折磨了我小半周，好在有传奇学长 Yffffff 热心相助。为铭记传奇学长，故写个Blog记录一下。\n树状数组的概念及其构建 概念 树状数组是一种用于高效处理数组前缀和相关问题的数据结构。它能在对数时间内实现单点更新和区间查询操作，相比普通数组遍历求和，大大提高了效率，常用于解决数据统计、动态区间求和等问题。\n构建过程 一. 最粗暴版（即依次两两求和）\n查询过程\neg：要计算前15个数字的和，只需要计算4个数字即可\n二. 离散化版\n我们发现，表中的这些数字对于查询没有任何的帮助，去掉后如下。\n剩下的数据按照出现顺序写成一排如下：\n不难发现：这个数组和原始数据正好一样长！\n我们就构建了一个离散化的树状数组，而树状数组中的每一个元素，刚好对应下面每一个区间。\n对于查询： 我们从要查找的元素位置依次向左向上推，相加即是答案。\n对于修改： 我们从要查找的元素位置依次向右向上推，每个数都相加上修改的值。\n三. 视频\n代码核心：lowbit()函数介绍 这个函数会求出一个二进制数字的最低位代表哪个数字\n代码如下：\n1 2 3 4 int lowbit(int x) { return x \u0026amp; -x; } 而对于离散化的树状数组，我们发现：\n1. 其中第k个元素对应的下标的lowbit刚好等于其所对应的原数组中的元素长度\n2. 其中第k个元素对应正上方的序列的元素下标正好就是lowbit(k)+k\n因此，查询时，只需要不断的循环加上b[k]+b[k-lowbit(k)]直到开头为止，进行相加；修改时，只需要不断加上lowbit(k)就可以找到上方的所有序列，进行修改。\n代码实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int lowbit(int x) { return x \u0026amp; -x; } void add(int pos,int x) { while(pos\u0026lt;=n) { tree[pos]+=x; pos+=lowbit(pos); } } int sum(int pos) { int ans = 0; while(pos) { ans+=tree[pos]; pos-=lowbit(pos); } return ans; } 树状数组在求逆序对问题上的应用 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct node{ int val,pos; bool operator\u0026lt;(const node x) { if(val==x.val) return pos\u0026gt;x.pos;//值一样，位置大的现在前面 return val \u0026gt; x.val;//不然值大的在前面 } }; int a[N]; vector\u0026lt;node\u0026gt; vt; vector\u0026lt;int\u0026gt; arr[N]; void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) { cin\u0026gt;\u0026gt;a[i]; vt.push_back({a[i],i}); arr[a[i]].push_back(i); } sort(vt.begin(),vt.end()); for(auto k:vt) { int pos=k.pos; res+=sum(pos-1); add(pos,1); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; } F - Rotated Inversions 归并排序实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026#34;bits/stdc++.h\u0026#34; #define int long long using namespace std; const int N = 2e6 + 10; //100005 int n,m; int a[N]; int b[N]; vector\u0026lt;int\u0026gt; arr[N]; int mergesort(int l,int r) { if(l\u0026gt;=r) return 0; int mid = (l+r) \u0026gt;\u0026gt; 1; int res = mergesort(l,mid) + mergesort(mid+1,r); int i = l,j = mid+1,k = l; while(i\u0026lt;=mid\u0026amp;\u0026amp;j\u0026lt;=r) { if(a[i]\u0026lt;=a[j]) b[k++] = a[i++]; else { b[k++] = a[j++]; res += mid - i + 1; //如果发生从j后面中拿元素，说明a中i位置全比该元素大 //所以构成了mid-i+1个逆序对 } } while(i\u0026lt;=mid) b[k++] = a[i++]; while(j\u0026lt;=r) b[k++] = a[j++]; for(int i=l;i\u0026lt;=r;i++) a[i] = b[i]; return res; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for(int i=1;i\u0026lt;=n;i++) { cin\u0026gt;\u0026gt;a[i]; arr[a[i]].push_back(i); } int res = mergesort(1,n); cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; for(int k=1;k\u0026lt;=m-1;k++) { for(int j=0;j\u0026lt;(int)arr[m-k].size();j++) { res+=arr[m-k][j]-1-j; res-=(n-arr[m-k][j]-(arr[m-k].size()-j-1)); } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; // cin \u0026gt;\u0026gt; _ ; while(_--) { solve(); } return 0; } 树状数组实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include \u0026#34;bits/stdc++.h\u0026#34; #define int long long using namespace std; const int N = 2e6 + 10; //100005 struct node{ int val,pos; bool operator\u0026lt;(const node x) { if(val==x.val) return pos\u0026gt;x.pos; return val \u0026gt; x.val; } }; int n,m,res; int a[N],tree[N]; vector\u0026lt;int\u0026gt; arr[N]; vector\u0026lt;node\u0026gt; vt; int lowbit(int x) { return x \u0026amp; -x; } void add(int pos,int x) { while(pos\u0026lt;=n) { tree[pos]+=x; pos+=lowbit(pos); } } int sum(int pos) { int ans = 0; while(pos) { ans+=tree[pos]; pos-=lowbit(pos); } return ans; } void solve() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=n;i++) { cin\u0026gt;\u0026gt;a[i]; vt.push_back({a[i],i}); arr[a[i]].push_back(i); } sort(vt.begin(),vt.end()); for(auto k:vt) { int pos=k.pos; res+=sum(pos-1); add(pos,1); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; endl; for(int k=1;k\u0026lt;=m-1;k++) { for(int j=0;j\u0026lt;(int)arr[m-k].size();j++) { res+=arr[m-k][j]-1-j; res-=(n-arr[m-k][j]-(arr[m-k].size()-j-1)); } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } signed main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); int _ = 1; // cin \u0026gt;\u0026gt; _ ; while(_--) { solve(); } return 0; } 两段代码关键点解释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 for(int k=1;k\u0026lt;=m-1;k++) //遍历 k 从 1 到 (M - 1)的所有可能取值。对于每个 k 值，都要计算对应序列 B 的逆序对数量 { for(int j=0;j\u0026lt;(int)arr[m-k].size();j++) //当 k 增加 1 时，原序列中值为 (m - k) 的元素，在新的 B 序列里会变成值为 0 的元素，因为 (m - k + 1) mod M = 0 //意思是把这次加上k等于M的数全部找出来，因为M mod M = 0,意味着此时这个数小于序列中的任何数，与他前面的数新构成了逆序对 { res+=arr[m-k][j]-1-j; //arr[m - k][j] - 1 表示该元素前面一共有多少个元素 //j 表示在 arr[m - k] 这个数组里，该元素前面值同样为 (m - k) 的元素个数 //所以 arr[m - k][j] - 1 - j 就代表该元素前面值小于 (m - k) 的元素数量 //当 k 增加 1 后，这个元素的值变为 0，它会和前面那些不等于这个数且值小于 (m - k) 的元素构成新的逆序对 //所以对前面的数（排除和这个数相等的），要加上这个数的贡献 res-=(n-arr[m-k][j]-(arr[m-k].size()-j-1)); //n - arr[m - k][j] 表示该元素后面元素的总数 //arr[m - k].size() - j - 1 表示在 arr[m - k] 里，该元素后面值同样为 (m - k) 的元素个数 //所以 n - arr[m - k][j] - (arr[m - k].size() - j - 1) 就代表该元素后面值大于 (m - k) 的元素数量 //当 k 增加 1 后，这个元素的值变为 0，它和后面那些不等于这个数且值大于 (m - k) 的元素就不再构成逆序对了 //所以要从 res 里减去他的贡献 } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } ","date":"2025-03-18T00:00:00Z","permalink":"https://zephyrbd.github.io/p/treelikearr/","title":"树状数组（含Rotated Inversions题解）"},{"content":"写在前面 循环结构是一种允许程序反复执行某些代码块的控制结构。常见的循环结构包括：\nwhile 循环：当条件为 True 时，重复执行代码块。 for 循环：遍历一个序列中的每个元素时，执行代码块。 while 循环 语法格式 1 2 while \u0026lt;条件\u0026gt;: 语句块 while 是循环关键字，后面跟一个条件表达式。 \u0026lt;条件\u0026gt;是一个布尔表达式，当其结果为 True 时执行循环体中的代码块。 语句块是在条件成立时执行的代码。需要注意的是，语句块中的代码必须缩进（通常为 4 个空格）。 流程\n首先判断 \u0026lt;条件\u0026gt; 是否为 True。 如果条件为 True，执行 语句块。 然后再次判断 \u0026lt;条件\u0026gt;，如此循环，直到条件为 False。 当条件为 False 时，退出循环，执行循环后的代码。 简单示例\n1 2 3 4 i = 1 while i \u0026lt;= 5: print(f\u0026#34;第 {i} 次循环\u0026#34;) i += 1 初始化变量 i = 1。 当 i \u0026lt;= 5 为 True 时，执行打印语句并递增 i。 当 i 增加到 6 时，条件 i \u0026lt;= 5 为 False，循环终止。 while循环的应用场景 条件驱动循环 根据特定条件执行操作，如用户输入数据直到符合要求。 示例：提示用户输入一个大于 10 的数字，如果不符合则继续提示。 1 2 3 4 number = int(input(\u0026#34;请输入一个大于10的数字: \u0026#34;)) while number \u0026lt;= 10: number = int(input(\u0026#34;数字太小，请重新输入: \u0026#34;)) print(\u0026#34;输入正确！\u0026#34;) 处理用户输入 使用 while 循环控制菜单选项的展示，直到用户选择退出。 示例：简单的文本菜单系统 示例\n1 2 3 4 5 6 7 8 9 while True: print(\u0026#34;1. 查看余额\u0026#34;) print(\u0026#34;2. 存款\u0026#34;) print(\u0026#34;3. 取款\u0026#34;) print(\u0026#34;4. 退出\u0026#34;) choice = input(\u0026#34;请选择操作: \u0026#34;) if choice == \u0026#39;4\u0026#39;: break # 其他操作逻辑 for循环 语法格式 1 2 for \u0026lt;变量\u0026gt; in \u0026lt;可迭代对象\u0026gt;: 语句块 for 是循环关键字。 \u0026lt;变量\u0026gt; 是每次循环时从 \u0026lt;可迭代对象\u0026gt; 中获取的元素。 in 关键字表示循环的范围或对象。 \u0026lt;可迭代对象\u0026gt; 可以是列表、元组、字符串或其他可迭代对象。 语句块是对每个元素执行的代码，通常缩进（4个空格）。 简单示例\n1 2 3 fruits = [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;] for fruit in fruits: print(fruit) fruits 是一个列表，包含三个字符串元素。 每次迭代时，将列表中的一个元素赋值给 fruit 变量。 打印当前元素。 range() 函数与 for 循环 range() 函数说明\n1 2 3 range(stop) # 生成从 0 到 stop-1 的整数序列 range(start, stop) # 生成从 start 到 stop-1 的整数序列 range(start, stop, step) # 生成从 start 到 stop-1，间隔为 step 的整数序列 示例：使用循环打印乘法口诀表\n1 2 3 for i in range(1, n+1): for j in range(i, 2*i+1): print(f\u0026#34;{i*j}\u0026#34;) 外层循环遍历 i 从 1 到 n。 内层循环遍历 j 从 i 到 2*i + 1，打印乘积。 嵌套 for 循环 定义 for 循环可以嵌套使用。 示例\n1 2 3 for i in range(3): for j in range(2): print(f\u0026#34;i={i}, j={j}\u0026#34;) 外层循环遍历 i 从 0 到 2。 内层循环遍历 j 从 0 到 1，打印每个组合。 for 循环的常见使用场景 遍历字符串： 1 2 3 s = \u0026#34;hello\u0026#34; for c in s: print(c) 遍历列表（集合、元组）： 1 2 3 4 5 my_list = [10, 20, 30] sum_ = 0 for num in my_list: sum_ += num print(sum_) 遍历字典： 1 2 3 4 5 6 7 students = { \u0026#34;Name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;Age\u0026#34;: 18, \u0026#34;Score\u0026#34;: 85 } for key, value in students.items(): print(f\u0026#34;{key}: {value}\u0026#34;) 与 range 组合使用： 1 2 3 4 for i in range(5): print(i) for j in range(i+1): print(f\u0026#34;i={i}, j={j}\u0026#34;) 循环的控制语句 break 语句 break 用于立即退出循环，无论循环条件是否为 True。 示例\n1 2 3 4 5 6 i = 1 while i \u0026lt;= 10: if i == 5: break # 当 `i` 等于 5 时，退出循环 print(i) i += 1 1 2 3 4 for i in range(5): if i \u0026gt; 2: break print(i) 在这个示例中，当 i 等于 5 时，循环会被提前终止。 continue 语句 continue 用于跳过当前循环中的剩余语句，并直接进入下一次循环的判断。\n示例\n1 2 3 4 5 6 i = 0 while i \u0026lt; 5: i += 1 if i == 3: continue # 跳过打印 `i` 为 3 的情况 print(i) 1 2 3 4 for i in range(3): if i == 1: continue print(i) 当 i 等于 3 时，循环会跳到下一次循环的判断，避免执行后续代码。 else 子句 当循环正常结束时（没有被 break 终止），else 子句会执行。\n1 2 3 4 5 6 i = 1 while i \u0026lt;= 5: print(i) i += 1 else: print(\u0026#34;循环结束\u0026#34;) 1 2 3 4 for i in range(3): print(i) else: print(\u0026#34;循环结束\u0026#34;) 无限循环和死循环 无限循环 如果循环的条件始终为 True，则循环将永远不会结束，这被称为无限循环。 示例\n1 2 while True: print(\u0026#34;这是一条无限循环语句\u0026#34;) 这个循环会一直打印 \u0026ldquo;这是一条无限循环语句\u0026rdquo;，除非手动停止程序。 避免死循环 为了避免死循环，在编写 while 循环时，需要确保在循环体内有逻辑使得循环条件最终会变为 False。 示例 1 2 3 4 i = 1 while i \u0026lt;= 5: print(i) # 忘记递增 `i`，会导致死循环 在这个示例中，如果忘记递增 i，循环将永远不会结束。 解决方法： 在循环体内正确更新控制条件变量，如 i += 1。 示例 1 2 3 4 5 6 i = 1 while i \u0026lt;= 5: print(i) i += 1 else: print(\u0026#34;循环正常结束\u0026#34;) 当 i 增加到 6 时，条件为 False，循环正常结束，执行 else 子句。 常见的陷阱和最佳实践 避免死循环：确保在循环体内有逻辑使得条件最终会变为 False。 控制语句的使用：合理使用 break 和 continue 可以使循环更灵活，但滥用可能使代码难以理解。 循环条件的检查：在编写 while 循环时，仔细检查循环条件，确保逻辑正确。 避免在循环中修改列表：可能导致不可预见结果。 合理使用控制语句：提高代码可读性和效率，但避免滥用。 使用 range() 和 enumerate() 简化代码：减少手动维护索引的需求。 ","date":"2025-02-18T00:00:00Z","image":"https://zephyrbd.github.io/images/Pydev/dev6/img0.png","permalink":"https://zephyrbd.github.io/p/pythondev_6/","title":"循环结构（while and for）"},{"content":"1. 数值类型 Python 提供了几种主要的数值类型，用于表示和操作不同种类的数值。\n整数 (int) 整数类型表示没有小数部分的数值，可以是正数、负数或零。\n1 2 3 x = 10 y = -3 z = 0 浮点数 (float) 浮点数类型表示带有小数部分的数值，用于表示实数。\n1 2 3 a = 3.14 b = -0.5 c = 2.0 复数 (complex) 复数类型用于表示具有实部和虚部的数值，表示为 a + bj 的形式，其中 a 是实部，b 是虚部。常用于科学计算，程序员使用较少。\n1 2 d = 1 + 2j e = -3j 2. 查看数据类型 内建函数 type 可以用来查看变量的类型。\n1 2 print(type(\u0026#39;name\u0026#39;)) print(type(8)) 运行结果：\n1 2 \u0026lt;class\u0026#39;str\u0026#39;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; 3. 算术运算符 Python 提供了丰富的算术运算符，用于对数值进行各种基本的数学运算。\n运算类型 运算符 描述 加法运算 + 两个数相加 减法运算 - 两个数相减 乘法运算 * 两个数相乘 除法运算 / 两个数相除 取整除（商） // 两个数相除并取整 取余数运算 % 两个数相除并取余数 幂运算 ** 比如 2**3：计算 2 的 3 次方 加法 (+) 加法运算符用于将两个数相加。\n1 2 3 4 num1 = 5 num2 = 3 result = num1 + num2 print(result) # 输出8 减法 (-) 减法运算符用于从第一个数中减去第二个数。\n1 2 3 4 num1 = 5 num2 = 3 result = num1 - num2 print(result) # 输出2 乘法 (*) 乘法运算符用于将两个数相乘。\n1 2 3 4 num1 = 5 num2 = 3 result = num1 * num2 print(result) # 输出15 除法 (/) 除法运算符用于将第一个数除以第二个数，返回浮点数结果。\n1 2 3 4 num1 = 5 num2 = 3 result = num1 / num2 print(result) # 输出1.6666666666666667 整数除法 (//) 整数除法运算符用于将第一个数除以第二个数，返回向下取整后的整数结果。\n1 2 3 4 num1 = 5 num2 = 3 result = num1 // num2 print(result) # 输出1 取余运算 (%) 取余运算符用于返回两个数相除后的余数。\n1 2 3 4 num1 = 5 num2 = 3 result = num1 % num2 print(result) # 输出2 幂运算 (**) 幂运算符用于将第一个数作为底数，第二个数作为指数，进行指数运算。\n1 2 3 4 num1 = 2 num2 = 3 result = num1 ** num2 print(result) # 输出8 4. 运算符优先级 在 Python 中，不同的算术运算符有不同的优先级。乘法、除法、取余和幂运算符的优先级高于加法和减法运算符。括号 () 可以用于改变运算的顺序，括号内的表达式总是最先计算。\n5. 生成随机数 random 模块用于生成随机数。\n生成随机整数： 使用 random.randint(a, b)，生成一个在 a（包括）到 b（包括）之间的随机整数。\n1 2 3 import random random_num = random.randint(1, 10) print(random_num) 生成随机浮点数： 使用 random.random()，生成一个在 0（包括）到 1（不包括）之间的随机浮点数。\n1 2 3 import random random_float = random.random() print(random_float) ","date":"2025-02-15T00:00:00Z","image":"https://zephyrbd.github.io/images/Pydev/dev4/img0.png","permalink":"https://zephyrbd.github.io/p/pythondev_4/","title":"数值和算术运算"},{"content":"条件运算 布尔型 布尔型（bool）表示条件的真假，只有两个取值：True（真）和 False（假）。\n任何数据都可以通过 bool() 函数转换为布尔型。 空数据（如 0, 0.0, \u0026rsquo;\u0026rsquo; 等）转换为 False，其他值为 True。 比较运算符 用于比较相同类型的数据，结果为布尔型。常用比较运算符：\n大于：\u0026gt; 小于：\u0026lt; 大于等于：\u0026gt;= 小于等于：\u0026lt;= 不等于：!= 相等：== 逻辑运算符 用于组合多个条件。常用逻辑运算符：\nand（与）：多个条件同时成立，结果为 True。 or（或）：多个条件只需一个成立，结果为 True。 not（非）：取反，将 True 变为 False，反之亦然。 成员运算符 用于测试一个值是否存在于序列或集合中。成员运算符：\nin：如果找到值在序列中，返回 True。 not in：如果未找到值在序列中，返回 False。 身份运算符 用于比较两个对象的内存地址，即判断两个对象是否为同一对象。身份运算符：\nis：如果两个变量引用同一个对象，返回 True。 is not：如果两个变量引用不同对象，返回 False。 条件分支 条件分支语句使程序能够根据条件的真假来决定执行哪一部分代码。主要包括三种结构：\n单分支：仅在条件成立时执行语句块。 二分支：根据条件的真假分别执行不同的语句块。 多分支：根据多个条件中的一个成立情况执行相应的语句块。 单分支结构 语法格式：\n1 2 if \u0026lt;条件\u0026gt;: 语句块 if 是关键字，后有一个空格。 \u0026lt;条件\u0026gt; 是表达式，其结果为布尔型。 条件语句结束后必须使用冒号 :。 语句块是条件成立后执行的一条或多条语句，必须缩进（4个空格）。 案例解释：\n用户输入考试成绩，判断成绩是否及格（60分及格）。\n1 2 3 score = input(\u0026#39;请输入您的考试成绩:\u0026#39;) if score \u0026gt;= 60: print(\u0026#34;您的考试成绩及格了，晚上加鸡腿!\u0026#34;) 二分支结构 语法结构：\n1 2 3 4 if \u0026lt;条件\u0026gt;: 语句块1 else: 语句块2 如果 \u0026lt;条件\u0026gt; 成立，执行 语句块1。 如果 \u0026lt;条件\u0026gt; 不成立，执行 语句块2。 案例解释：\n用户输入考试成绩，判断成绩是否及格。\n1 2 3 4 5 score = input(\u0026#39;请输入您的考试成绩:\u0026#39;) if score \u0026gt;= 60: print(\u0026#34;您的考试成绩及格了，晚上加鸡腿!\u0026#34;) else: print(\u0026#34;考试不及格，晚上通宵学代码！\u0026#34;) 多分支结构 语法结构：\n1 2 3 4 5 6 7 8 9 if \u0026lt;条件1\u0026gt;: 代码块1 elif \u0026lt;条件2\u0026gt;: 代码块2 ... elif \u0026lt;条件n-1\u0026gt;: 代码块n-1 else: 代码块n 从第一个条件开始，哪个条件成立，就执行对应的代码块。 如果没有任何条件成立，则执行 else 下的代码块（else 是可选的）。 案例解释：\n用户输入成绩，程序根据不同的分数区间判断并输出成绩等级（A, B, C, D, E）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 score = float(input(\u0026#34;请输入您的考试成绩:\u0026#34;)) if score \u0026lt; 40: grade = \u0026#34;E\u0026#34; elif score \u0026lt;= 59: grade = \u0026#34;D\u0026#34; elif score \u0026lt;= 75: grade = \u0026#34;C\u0026#34; elif score \u0026lt;= 85: grade = \u0026#34;B\u0026#34; elif score \u0026lt;= 100: grade = \u0026#34;A\u0026#34; else: grade = \u0026#34;无效成绩\u0026#34; print(f\u0026#34;您的成绩等级为: {grade}\u0026#34;) Match-Case 语句 概述 match-case 是 Python 3.10 引入的一项新特性，旨在通过模式匹配简化条件判断逻辑。它不仅适用于简单值，还能处理序列、字典和类实例等复杂数据结构。\n关键点：\nmatch-case 比传统的 if-elif-else 结构更直观，尤其适合多分支场景。 它支持多种匹配类型，如常数、列表、字典、对象等。 基本语法 1 2 3 4 5 6 7 8 match \u0026lt;表达式\u0026gt;: case \u0026lt;模式1\u0026gt;: 语句块1 case \u0026lt;模式2\u0026gt;: 语句块2 ... case _: 语句块n+1 # 处理所有其他情况 解释：\nmatch 后跟一个表达式，用于获取匹配值。 每个 case 后面是要测试的模式。匹配成功时执行相应语句块。 _ 用于默认情况，类似于传统的 else 语句。 使用守卫条件 1 2 3 4 5 6 7 match number: case n if n \u0026gt; 0: print(f\u0026#34;{n} 大于0\u0026#34;) case n if n \u0026lt; 0: print(f\u0026#34;{n} 小于0\u0026#34;) case _: print(f\u0026#34;{n} 等于0\u0026#34;) 解释：\n在 case 后添加 if 关键字，可以对匹配结果进行额外判断。 这有助于精确控制匹配逻辑，适用于需要多层次条件检查的情况。 高级模式匹配 匹配序列 1 2 3 4 5 6 7 8 9 10 11 point = (2, 1) match point: case (0, 0): print(\u0026#34;点位于坐标原点\u0026#34;) case (0, y): print(f\u0026#34;数据位置在y轴上，y={y}\u0026#34;) case (x, 0): print(f\u0026#34;数据位置在x轴上，x={x}\u0026#34;) case (x, y): print(f\u0026#34;坐标为({x}, {y})\u0026#34;) 解释：\n使用元组模式匹配，可以处理多种点的位置情况。 每个 case 检查点的不同组合，并执行相应的操作。 匹配字典 1 2 3 4 5 6 7 8 9 user = {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30} match user: case {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;}: print(\u0026#34;用户是Alice\u0026#34;) case {\u0026#34;age\u0026#34;: 25}: print(\u0026#34;年龄是25岁\u0026#34;) case _: print(\u0026#34;未匹配到任何条件\u0026#34;) 解释：\n对于字典，可以匹配特定的键值对。 使用通配符 _ 处理未列出的情况，避免遗漏。 注意事项 模式匹配顺序： match-case 会按定义的顺序检查每个 case，一旦找到匹配的情况，就会执行该语句块，不再继续检查后续的条件。\n不可变对象： match-case 最适合处理不可变对象，如数字、字符串和元组，因为它们在匹配时不会改变状态。要谨慎使用可变对象（如列表），因为可能导致意外行为。\n默认情况： 建议始终包含一个 case _，用于处理所有未被其他 case 处理的情况，这样可以避免遗漏。\n","date":"2025-02-15T00:00:00Z","image":"https://zephyrbd.github.io/images/Pydev/dev5/img0.png","permalink":"https://zephyrbd.github.io/p/pythondev_5/","title":"条件语句（if and match-case）"},{"content":"输入函数：input input()函数用于从标准输入（通常是键盘输入）读取一行字符串，并在用户按下回车键后返回该字符串。这个函数常用于获取用户的输入信息。\n基本用法\n1 name = input() # 注意`input`的后面要加上`()`，表示执行函数 带提示的 input 函数 input函数可以接收一个字符串参数，用来在提示用户输入时显示。这个参数通常用于给用户更直观的提示，告诉他们应该输入什么内容。\n1 name = input(\u0026#39;请输入您的姓名\u0026gt;\u0026gt;\u0026gt;:\u0026#39;) 输出函数：print print函数的作用是内置函数print()用于将传入的内容输出到标准输出（通常是控制台）。print函数会将传入的值转换为字符串后输出，并默认在输出后加上一个换行符。\n基本用法\n1 2 print(\u0026#39;张三\u0026#39;) print(\u0026#39;李四\u0026#39;) 上述代码会在控制台上分别输出“张三”和“李四”，并且每个名字占一行。\n不换行输出 print函数可以通过end参数来控制输出后的行为。默认情况下，end的值是\\n（换行符），但你可以将其设置为其他值，如空字符串，以避免换行。\n1 2 print(\u0026#39;大帅哥\u0026#39;, end=\u0026#39;\u0026#39;) print(\u0026#39;张三\u0026#39;) 以上代码将会在同一行打印“大帅哥张三”。\n打印多个值 print函数可以接收多个值，并默认以空格分隔这些值。\n1 print(\u0026#39;张三\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;18\u0026#39;) 上述代码将输出：“张三 男 18”。\n","date":"2025-02-13T00:00:00Z","image":"https://zephyrbd.github.io/images/Pydev/dev3/img0.png","permalink":"https://zephyrbd.github.io/p/pythondev_3/","title":"Python的输出和输入"},{"content":"知识点介绍： 桶排序： 桶排序的思想是若待排序的值在一个明显有限范围内（整型）时，可设计有限个有序桶，待排序的值装入对应的桶（当然也可以装入若干个值），桶号就是待排序的值，顺序输出各桶的值，将得到有序的序列。\n例:输入n个0到100之间的整数,由小到大排序输出。\n【程序实现】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int main() { int b[101],n,k; memset(b,0,sizeof(b));\t//初始化 cin \u0026gt;\u0026gt; n; for(int i=1;i\u0026lt;=n;i++) { cin \u0026gt;\u0026gt; k; b[k]++;\t//将等于k的值全部装入第k桶中 } for(int i=0;i\u0026lt;=100;i++)\t//输出排序结果 { while(b[i]\u0026gt;0)\t//相同的整数，要重复输出 { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; b[i]--;\t//输出一个整数后，个数减1 } } cout \u0026lt;\u0026lt; endl; return 0; } 运行结果\n样例输入：\n1 2 10 2 3 1 2 4 55 3 55 3 2 样例输出：\n1 1 2 2 2 3 3 3 4 55 55 read()函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //read 函数在处理大量整数输入时，由于其简单的实现和直接的字符读取，性能更优。 void read(ll \u0026amp;x){ int f=1;x=0;char s=getchar(); while(s\u0026lt;\u0026#39;0\u0026#39;||s\u0026gt;\u0026#39;9\u0026#39;) { if(s==\u0026#39;-\u0026#39;) f=-1; s=getchar(); } while(s\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s\u0026lt;=\u0026#39;9\u0026#39;) { x=x*10+s-\u0026#39;0\u0026#39;; s=getchar(); } x*=f; } Hydro题目： 题目背景 本题除【数据范围与约定】外与 P1090 完 全 一 致。\n题目描述 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。\n每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过(n−1)次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。\n因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。\n例如有 3 堆果子，数目依次为 1, 2, 9。可以先将 1、2堆合并，新堆数目为 3，耗费体力为 3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。所以多多总共耗费体力为 3+12=15。可以证明 15 为最小的体力耗费值。\n输入格式\n输入的第一行是一个整数 n，代表果子的堆数。\n输入的第二行有 n 个用空格隔开的整数，第 i 个整数代表第 i 堆果子的个数 ai。\n输出格式\n输出一行一个整数，表示最小耗费的体力值。\n输入数据 1\n1 2 3 1 2 9 输出数据 1\n1 15 提示 【数据规模与约定】\n本题采用多测试点捆绑测试，共有四个子任务。\nSubtask 1（10 points）：1≤n≤8。\nSubtask 2（20 points）：1≤n≤10^3。\nSubtask 3（30 points）：1≤n≤10^5。\nSubtask 4（40 points）：1≤n≤10^7。\n对于全部的测试点，保证 1≤ai≤10^5。\n【提示】\n请注意常数因子对程序效率造成的影响。 请使用类型合适的变量来存储本题的结果。 本题输入规模较大，请注意数据读入对程序效率造成的影响。 题解： 思路： 这道题很有意思，也很清真。贪心思路想必大家都已经了解了，就是每一次选取最小的两堆果子进行合并，但是我们怎么选取呢？优先队列确实是一种比较优秀的解法，但是他还不够优秀，这里要求是O(n)的算法。我们回归问题的本质，我们还是要选取最小的两堆果子，最清真、最自然的方式显然是排序了吧。先排序，选取最小的两堆果子，然后合并，插入。但是插入的效率太低了，我们想要优化。我们可以把这些需要插入的点用一个队列存储起来，首先这些需要插入的点肯定会越来越大 显然 ， 这相当于延迟插入。当我们目标插入点就是我们当前最小的那一堆的时候，我们就把他插入进来。以上是精神，代码写出来大概就是，桶排，建立两个队列，排序结果放进第一个当中，合并结果放在第二个当中，每次选从两个队列队头选取比较小的合并。——洛谷题解\n个人代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; using ll = long long; const int N = 100010; //100005 queue\u0026lt;ll\u0026gt; q1,q2; ll n,to[N],ans; //read 函数在处理大量整数输入时，由于其简单的实现和直接的字符读取，性能更优。 void read(ll \u0026amp;x){ int f=1;x=0;char s=getchar(); while(s\u0026lt;\u0026#39;0\u0026#39;||s\u0026gt;\u0026#39;9\u0026#39;) { if(s==\u0026#39;-\u0026#39;) f=-1; s=getchar(); } while(s\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;s\u0026lt;=\u0026#39;9\u0026#39;) { x=x*10+s-\u0026#39;0\u0026#39;; s=getchar(); } x*=f; } int main() { ios::sync_with_stdio(0); cin.tie(0),cout.tie(0); read(n); //桶排序-Begin for(int i=1;i\u0026lt;=n;i++) { ll a; read(a); to[a]++; } for(int i=1;i\u0026lt;=N-10;i++) { while(to[i]\u0026gt;0) { to[i]--; q1.push(i); } } //桶排序-End for(int i=1;i\u0026lt;n;i++) { ll x,y; if((q1.front()\u0026lt;q2.front() \u0026amp;\u0026amp; !q1.empty()) || q2.empty()) { x = q1.front(); q1.pop(); } else { x = q2.front(); q2.pop(); } if((q1.front()\u0026lt;q2.front() \u0026amp;\u0026amp; !q1.empty()) || q2.empty()) { y = q1.front(); q1.pop(); } else { y = q2.front(); q2.pop(); } ans += x+y; q2.push(x+y); } cout \u0026lt;\u0026lt; ans; return 0; } 参考资料 信息学奥赛一本通（第五版）—— 董永建（P196：桶排序）\n","date":"2025-01-20T00:00:00Z","permalink":"https://zephyrbd.github.io/p/hydro-luogu-p6033/","title":"P6033. [NOIP2004 提高组] 合并果子 加强版题解"},{"content":"变量定义和赋值 变量的概念 什么是变量： 变量是编程中的基本概念，用于存储数据和在程序中进行各种操作。它们是程序中用于保存和处理信息的“容器”。\n变量的作用：\n存储数据： 变量可以存储用户输入的数据、计算结果、中间数据等。例如，用户输入的年龄、计算出的总和、读取的文件内容等都可以存储在变量中。 引用数据： 通过变量名可以在程序的不同部分引用或访问存储的数据。变量名是对存储在内存中数据的引用。 类型灵活： 在 Python 中，变量可以存储各种类型的数据，如整数、浮点数、字符串、列表、字典等。 PS：在Python中，定义变量基本变量一般不给出变量类型的定义，Python会自动根据变量被赋的值进行判断。\n变量赋值 将数据放入变量保存的过程叫做赋值\nPS:\n这里的等号=叫做赋值运算符。 所有的编程语言都是用=作为赋值运算符。 python中，变量的定义和赋值是在一条语句中实现的。 =的左边叫做左值，=的右边叫做右值。 1 2 3 4 age = 17 # 给变量赋值 age = 18 # 具体的值 age1 = age # 变量 age2 = age + 1 # 表达式 一个变量被声明后，在其后的代码中就可以使用了，可以参与运算，可以赋值给其他变量，也可以作为参数传给某个函数。\n变量的命名规则 在编程中，变量的命名规则非常重要，遵守这些规则可以避免语法错误，并提高代码的可读性和可维护性。以下是 Python 变量命名时必须遵守的规则：\n变量名由字母、数字和下划线组成 变量名只能包含 字母（a-z, A-Z）、数字（0-9） 和 下划线（_）。 Python 区分大小写，因此 name 和 Name 是两个不同的变量。 Example:\n1 2 3 name = \u0026#34;ZehyrBD\u0026#34; # 正确 _age = 19 # 正确 ffl = 1.35 # 正确 变量名不能以数字开头 变量名必须以字母或下划线开头，不能以数字开头。 Example:\n1 2 1sex = 99 # 错误，不能数字开头 sex1 = 99 # 正确，数字在字母之后 变量名不能是 Python 的关键字 Python 的关键字是保留用于特殊用途的单词，不能用作变量名 Example:\n1 2 def = 100 # 错误，\u0026#39;def\u0026#39; 是关键字 for = 200 # 错误，\u0026#39;for\u0026#39; 是关键字 Python中的关键字(保留字) 关键字（或保留字）是 Python 内部设计时预留的具有特定功能的单词。这些关键字在 Python 代码中具有特殊含义，用来表示特定的操作或语法结构。因此，关键字不能被用作变量名、函数名或任何其他标识符，否则会导致语法错误。\n如何查看 Python 的关键字列表 Python 提供了一个内置的 keyword 模块，可以用来查看当前版本 Python 中的所有关键字。你可以使用以下代码来打印出这些关键字： 1 2 import keyword print(keyword.kwlist) 当你运行上面的代码时，将会输出 Python 当前版本中所有的关键字列表。以下是 Python 3中的关键字示例：\n1 2 3 4 5 [\u0026#39;False\u0026#39;, \u0026#39;None\u0026#39;, \u0026#39;True\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;as\u0026#39;, \u0026#39;assert\u0026#39;, \u0026#39;async\u0026#39;, \u0026#39;await\u0026#39;, \u0026#39;break\u0026#39;, \u0026#39;class\u0026#39;, \u0026#39;continue\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;del\u0026#39;, \u0026#39;elif\u0026#39;, \u0026#39;else\u0026#39;, \u0026#39;except\u0026#39;, \u0026#39;finally\u0026#39;, \u0026#39;for\u0026#39;, \u0026#39;from\u0026#39;, \u0026#39;global\u0026#39;, \u0026#39;if\u0026#39;, \u0026#39;import\u0026#39;, \u0026#39;in\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;lambda\u0026#39;, \u0026#39;nonlocal\u0026#39;, \u0026#39;not\u0026#39;, \u0026#39;or\u0026#39;, \u0026#39;pass\u0026#39;, \u0026#39;raise\u0026#39;, \u0026#39;return\u0026#39;, \u0026#39;try\u0026#39;, \u0026#39;while\u0026#39;, \u0026#39;with\u0026#39;, \u0026#39;yield\u0026#39;] Python 关键字列表解析 以下是一些常用关键字及其基本功能： 控制流关键字： if, elif, else：用于条件判断。 for, while：用于循环。 break, continue：用于控制循环的执行。 try, except, finally, raise：用于异常处理。 定义和声明关键字： def：用于定义函数。 class：用于定义类。 lambda：用于定义匿名函数。 import, from：用于导入模块。 逻辑运算关键字： and, or, not：用于逻辑运算。 is, in：用于比较运算。 其他常见关键字： return：用于从函数返回值。 yield：用于生成器函数，返回一个值并暂停函数的执行。 global, nonlocal：用于声明变量的作用域。 True, False, None：布尔值和空值。 注意事项 无需死记硬背：Python 的关键字数量有限（大约 35 个），这些关键字会在你编写代码时频繁使用。虽然刚开始可能需要查询关键字的具体功能，但随着编程经验的积累，你会逐渐熟悉这些关键字，并自然记住它们。因此，不需要刻意去死记硬背，反复练习和实际编程会帮助你掌握它们。 避免使用关键字作为变量名：如果不小心使用了关键字作为变量名，Python 会报语法错误。\n例如： 1 if = 5 # 这是非法的，会导致语法错误 关键字是区分大小写的：例如，True 是关键字，但 true 不是关键字，可以作为变量名使用。 通过理解并熟悉这些关键字，你将能够更有效地编写 Python 代码。随着编程经验的增长，你会逐渐内化这些关键字的用法。\n变量命名风格的建议（规范） 在遵守变量命名规则的前提下，变量的命名尽量要见名知意，一般使用英文单词，忌用拼音\n见名知意\n变量的命名应尽量清晰明确，能够反映其用途或包含的数据。避免使用与实际用途不符的名字。 Good Example：\n1 2 3 name = \u0026#34;ZephyrBD\u0026#34; # 变量名清楚地表明其保存的是名字 age = 20 # 变量名清楚地表明其保存的是年龄 total_price = 100 # 变量名清楚地表明其保存的是总价 Bad Example：\n1 2 3 mingzi = \u0026#34;ZephyrBD\u0026#34; # 使用拼音命名，容易引起困惑，不符合国际化编程习惯 mz = \u0026#34;ZephyrBD\u0026#34; # 变量名过于简短，无法清楚表达含义 tp = 100 # 变量名不清晰，不易理解其含义 使用英文单词\n尽量使用标准的英文单词来命名变量，而不是拼音或缩写。这能提高代码的可读性。 Good Example：\n1 2 height = 180 # 使用英文单词 birth_date = \u0026#34;1990-01-01\u0026#34; Bad Example：\n1 2 gao = 180 # 使用拼音，不利于他人理解 birthD = \u0026#34;1990-01-01\u0026#34; # 使用缩写，容易造成混淆 使用下划线分隔单词（蛇形命名法 | 下划线命名法）\n对于多个单词组成的变量名，使用下划线 _ 分隔每个单词，以增强可读性。这种命名方式称为“蛇形命名法”（snake_case），是 Python 社区推荐的命名风格。 Good Example：\n1 2 first_name = \u0026#34;John\u0026#34; # 单词之间使用下划线分隔 total_amount = 500 Bad Example：\n1 2 firstname = \u0026#34;John\u0026#34; # 单词直接连接，降低可读性 totalAmount = 500 # 使用驼峰命名法，不符合 Python 规范 避免使用保留字和内置函数名\n不要使用 Python 的保留字或内置函数名作为变量名，以免引起错误或困惑。\n保留字：if, else, while, for, class, try, except, import, from 等。 内置函数名：list, str, int, sum, print, len 等。 Good Example：\n1 2 my_list = [1, 2, 3] # 避免与内置函数名 `list` 冲突 count = 10 # 避免使用 `sum` 作为变量名 Bad Example：\n1 2 list = [1, 2, 3] # 覆盖了内置函数 `list` sum = 10 # 覆盖了内置函数 `sum` 保持命名风格一致 在同一个项目或模块中，保持变量命名风格的一致性非常重要。不要混合使用不同的命名风格（如蛇形命名法与驼峰命名法）。 Good Example：\n1 2 3 user_name = \u0026#34;Alice\u0026#34; user_age = 30 total_amount = 1000 Bad Example：\n1 2 3 userName = \u0026#34;Alice\u0026#34; # 驼峰命名法 user_age = 30 # 蛇形命名法 totalAmount = 1000 # 驼峰命名法 变量命名长度适中 变量名不宜过长或过短，过长会影响书写和阅读，过短则不利于理解。命名时，应在表达清晰和简洁之间取得平衡。 Good Example：\n1 2 product_name = \u0026#34;Laptop\u0026#34; # 长度适中，含义明确 price = 999 # 简短且清晰 Bad Example：\n1 2 p = 999 # 过于简短，含义不明确 name_of_the_product_we_sold = \u0026#34;Laptop\u0026#34; # 过长，冗余 通过遵循这些变量命名的建议和规范，可以大大提高代码的可读性、可维护性和专业性。这是非常重要的。\n注释和字符 注释 代码注释是为了提高代码的可读性和维护性。通过注释，在代码中记录下有关代码逻辑、目的、使用方法等信息，方便自己或其他人在后续的代码维护和修改过程中理解代码的意图\n单行注释：采用 # 开头， 表示这一行的内容是注释，不会被 Python 解释器执行 1 2 # 定义变量 x 并赋值为 10 x = 10 多行注释：使用三个引号（\u0026lsquo;\u0026lsquo;\u0026lsquo;注释\u0026rsquo;\u0026rsquo;\u0026rsquo; 或 \u0026ldquo;\u0026ldquo;\u0026ldquo;注释\u0026rdquo;\u0026quot;\u0026quot;）包裹 1 2 3 4 \u0026#34;\u0026#34;\u0026#34; 这是一个多行注释 可以用于较长的说明 \u0026#34;\u0026#34;\u0026#34; Docstring（文档字符串） ：文档字符串是 Python 特有的一种注释方式，通常用于函数、类或模块的说明。文档字符串也是使用三个引号包裹，但它们是用来生成文档的，而不仅仅是注释 1 2 3 4 5 6 7 8 9 10 11 12 def add(a, b): \u0026#34;\u0026#34;\u0026#34; 这个函数用于两个数字的加法运算。 参数: a -- 第一个加数 b -- 第二个加数 返回值: 两个加数的和 \u0026#34;\u0026#34;\u0026#34; return a + b Tips：\n注释应尽量简洁明了，描述清楚代码的意图。 对于复杂的代码逻辑，建议使用详细的注释，以帮助理解代码。 注释和代码之间保持适当的空白，以提高可读性 字符串 字符串是 Python 中一种非常重要的数据类型，用于表示和处理文本信息。字符串可以使用单引号、双引号或者三引号来定义，具体的选择取决于你所处理的文本内容。下面详细介绍字符串的各种定义方式及其使用方法。\n单引号、双引号定义单行字符串 1 2 3 4 name = \u0026#34;ZephyrBD” desc = \u0026#34;好好学习，天天向上\u0026#34; # 使用单引号和双引号进行字符串定义没有任何区别。 # 当单引号是字符串的一部分时用双引号定义字符串，反之亦然。 2、 三引号定义多行字符串定义（字符串跨行的时候使用）\n1 2 3 4 5 info = \u0026#34;\u0026#34;\u0026#34; 一大段多行字符串 第二行，bababa 第三行，6666 \u0026#34;\u0026#34;\u0026#34; PS：\n代码中所有的标点符号都要用英文格式的 字符串中有单引号时（外面得双引号包裹） 字符串中有双引号时（外面得单引号包裹） ","date":"2025-01-19T00:00:00Z","image":"https://zephyrbd.github.io/images/Pydev/dev2/img0.png","permalink":"https://zephyrbd.github.io/p/pythondev_2/","title":"变量的定义、注释和字符详解"},{"content":"Python下载和安装 下载 Python 打开官网，点击下载(选择自己的电脑系统)\n选择安装版本，点击下载（左侧为长期稳定的版本）\n安装Python 运行安装程序\n选择指定路径安装\n点击下一步，指定安装路径\n点击安装，等待安装成功\n安装成功的提示页面\nPython 的交互环境 python 安装好之后如何使用呢？\n打开 cmd 命令行，输入：python，即可运行python解释器(程序)，进入到 python 的交互环境中\n交互环境在进行程序开发的时候，很少会使用到，\n输入 Python 能看到版本信息，说明已经安装成功了就可以啦。\nPyCharm的下载和安装 下载安装包 PyCharm专业版是收费软件， 安装之后需要使用激活码激活才可以用。 PyCharm专业版对在校大学生免费授权(最推荐)， 可以去官网了解。 PyCharm社区版是免费的(推荐)， 对于初学者可以先使用社区版进行学习，社区版编写 python 代码功能完整足够，没必要在学习初期给自己增加学习的摩擦力，等到后面基础语法熟练了，pycharm 的基本使用熟悉了，要进行项目开发的时候，再去使用专业版。 PyCharm下载地址\n点击下载专业版\n点击下载社区版\n下载的安装包\n安装 PyCharm 双击运行安装程序\n指定安装路径\n勾选下面的选项，点击下一步\n点击安装\n安装过程中，等待安装完成即可\nPyCharm 基本使用教程 PyCharm 是一个集成开发环境 (IDE)，专门用于 Python 编程。对于初学者来说，PyCharm 社区版已经足够用于学习和开发基础项目。本节将带你一步步熟悉 PyCharm 的基本使用，包括项目创建、解释器配置、文件与文件夹的创建、代码运行，以及项目的退出和切换。\n项目创建 在 PyCharm 中，项目是一个文件夹，包含你所有的代码文件、资源文件和配置文件。每个项目都可以有自己的设置和虚拟环境。 步骤：\n打开 PyCharm，选择 New Project。 在弹出的窗口中，选择项目的保存位置。 为项目指定一个名称，并选择 Python 解释器（如未设置，可在后面配置）。 点击 Create，项目就会被创建。 PS：建议将项目保存在一个易于管理的位置，方便后续查找和管理。\n解释器的配置 Python 解释器是运行 Python 代码的核心组件。在 PyCharm 中，每个项目可以使用不同的解释器（如系统 Python 或虚拟环境中的 Python）。\n配置步骤：\n在创建项目时，如果未选择解释器，可以通过 File -\u0026gt; Settings -\u0026gt; Project: [Your Project Name] -\u0026gt; Python Interpreter 进行配置。 在解释器列表中，选择合适的解释器。如果没有合适的解释器，可以通过 Add Interpreter 添加一个新的 Python 解释器。 选择解释器后，点击 OK 保存设置。 PS：建议初学者使用系统自带的 Python 解释器，或者为每个项目创建一个虚拟环境，以确保依赖包的独立性。\n文件和文件夹的创建 在 PyCharm 中，你可以轻松地创建文件和文件夹，以组织你的代码和资源。\n创建步骤：\n在项目视图的侧栏中，右键点击项目名称或一个文件夹。 选择 New，然后选择 Python File 创建一个新的 Python 文件，或选择 Directory 创建一个新的文件夹。 为新文件或文件夹命名后，点击 Enter。 PS：文件命名应遵循 Python 命名规则（如使用下划线连接单词，尽量不要用中文）。\n代码的运行 在 PyCharm 中运行代码非常简单。你可以运行单个文件或整个项目中的多个文件。\n运行步骤：\n确保你已经在项目中创建了一个 Python 文件，并且文件中有可运行的代码。 打开你要运行的文件，然后右键点击编辑器中的代码区域，选择 Run \u0026lsquo;文件名\u0026rsquo;。 PyCharm 将在下方的 Run 窗口中显示运行结果和输出信息。 PS：你可以使用快捷键 Shift + F10 快速运行代码。\n项目的退出和切换 当你完成一个项目的工作或想要切换到另一个项目时，你可以轻松地在 PyCharm 中退出当前项目或切换到另一个项目。\n退出项目：\n关闭 PyCharm 窗口即可退出当前项目。\n下次打开 PyCharm 时，会自动加载上次关闭时的项目。\n切换项目：\n在 PyCharm 中，点击 File -\u0026gt; Open，然后选择另一个项目的目录。\n你可以选择在当前窗口打开新项目，或在新窗口中打开。\nPS：建议每次只在一个项目中工作，避免多个项目同时打开造成的资源占用和混乱。\n中文翻译插件安装 打开 PyCharm：\n启动 PyCharm，打开你的项目。 进入插件市场：\n在顶部菜单栏中，点击 File，然后选择 Settings（在 macOS 上是 PyCharm -\u0026gt; Preferences）。 在设置窗口的左侧菜单中，选择 Plugins。 搜索插件：\n在右上角的搜索框中输入 Translation 或 中文翻译 关键词。 常用的翻译插件有 Translation 或 Chinese Localization Plugin。你可以选择 Translation 插件，它支持多种语言的翻译，包括英文到中文。 安装插件：\n在搜索结果中找到合适的插件（例如 Translation），然后点击 Install 按钮进行安装。 安装完成后，可能需要重启 PyCharm 以激活插件。 安装汉化插件 在 PyCharm 中安装汉化插件（中文语言包）可以使 IDE 的界面变成中文。以下是安装汉化插件的步骤：\n打开 PyCharm：\n启动你的 PyCharm IDE。 进入插件市场：\n点击顶部菜单栏的 File，然后选择 Settings（在 Mac 上为 Preferences）。 在左侧导航栏中，选择 Plugins。 搜索汉化插件：\n在插件窗口中，点击右上角的搜索框，输入 Chinese 或 中文。 你应该能够找到一个名为 \u0026ldquo;Chinese (Simplified) Language Pack / 中文语言包\u0026rdquo; 的插件。 安装插件：\n找到插件后，点击 Install 按钮进行安装。 安装完成后，点击 Restart IDE 以重启 PyCharm 使插件生效。 切换语言：\n重启后，PyCharm 的界面将自动切换为中文。如果没有自动切换，可以在 File -\u0026gt; Settings -\u0026gt; Appearance \u0026amp; Behavior -\u0026gt; Appearance 中检查语言设置，确保语言包已应用。 ","date":"2025-01-18T00:00:00Z","image":"https://zephyrbd.github.io/images/Pydev/dev1/img0.png","permalink":"https://zephyrbd.github.io/p/pythondev_1/","title":"Python开发环境的搭建"},{"content":"参考视频： 盔甲注册的新方法 同\u0026quot;《MC 1.21.4 中工具物品注册方法及相关类变更详解》\u0026ldquo;这篇博客中所写的register方法大致一样，这里给个例子：\n1 2 3 public class ModItems { public static final Item GA_HELMET = register(\u0026#34;ga_helmet\u0026#34;, settings -\u0026gt; new ArmorItem(ModArmorMaterials.GALLIUM_ARMOR, EquipmentType.HELMET, settings)); } ModArmorMaterials类的变化 好消息：你Mojang又把这ModArmorMaterials改回interface（接口）了（真是活母操作）！\n于是你只需要新建一个接口类然后定义变量就好了。具体例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 public interface ModArmorMaterials { ArmorMaterial GALLIUM = new ArmorMaterial(20, Util.make(new EnumMap(EquipmentType.class), map -\u0026gt; { map.put(EquipmentType.BOOTS, 3); map.put(EquipmentType.LEGGINGS, 6); map.put(EquipmentType.CHESTPLATE, 8); map.put(EquipmentType.HELMET, 3); map.put(EquipmentType.BODY, 11); }), 10, SoundEvents.ITEM_ARMOR_EQUIP_IRON, 2.0F, 0.0F, ModItemTags.GALLIUM_TAG, ModEquipmentAssetKeys.GALLIUM); //SoundEvents.ITEM_ARMOR_EQUIP_IRON表示穿戴音效 //ModItemTags.GALLIUM_TAG表示修复材料 //ModEquipmentAssetKeys.GALLIUM表示装备穿戴的时候渲染相关的量（我不确定） } ModEquipmentAssetKeys类 这个是表示装备穿戴的时候渲染相关的量（我不确定），总之也是个接口类，写上如下变量：\n1 2 3 4 5 6 public interface ModEquipmentAssetKeys { RegistryKey\u0026lt;EquipmentAsset\u0026gt; GALLIUM = register(\u0026#34;gallium\u0026#34;); static RegistryKey\u0026lt;EquipmentAsset\u0026gt; register(String name) { return RegistryKey.of(REGISTRY_KEY, Identifier.of(\u0026lt;YOURMODID\u0026gt;,name)); } } PS：注意MOD_ID（这玩意卡了我半天，甚至还去Discord问了，结果是直接用了原版的方法发现原版写的是Identifier.ofVanilla(name)，淦！）。\n盔甲材质文件目录的变更 这里先给出老版本目录第三人称盔甲材质的目录结构：\n/main/resources/assets/\u0026lt;YOURMODID\u0026gt;/textures/models/armor/\n然后新版本改到了：\n/main/resources/assets/\u0026lt;YOURMODID\u0026gt;/textures/entity/equipment/humanoid 和\n/main/resources/assets/\u0026lt;YOURMODID\u0026gt;/textures/entity/equipment/humanoid_leggings下\n此外你还需要在： /main/resources/assets/\u0026lt;YOURMODID\u0026gt;/equipment下新建一个json，\n名字格式为RegistryKey\u0026lt;EquipmentAsset\u0026gt;变量名\n内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;layers\u0026#34;: { \u0026#34;humanoid\u0026#34;: [ { \u0026#34;texture\u0026#34;: \u0026#34;firstfabricmod:gallium\u0026#34; } ], \u0026#34;humanoid_leggings\u0026#34;: [ { \u0026#34;texture\u0026#34;: \u0026#34;firstfabricmod:gallium\u0026#34; } ] } } 注：这里省了马铠的声明，具体见原版的json。\ngetMaterial()方法的移除 Mojang移除了Item类中的getMaterial()方法，这导致在后面实现穿戴盔甲时给予玩家药水效果时不能用ExampleHelmet.getMaterial() = YourMaterial这样的句子，于是我直接改用了如下判断：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ModArmorItem extends ArmorItem { ··· private boolean hasCorrectArmorSet(PlayerEntity player) { Item helmet = player.getInventory().getArmorStack(3).getItem(); Item chestplate = player.getInventory().getArmorStack(2).getItem(); Item legging = player.getInventory().getArmorStack(1).getItem(); Item boots = player.getInventory().getArmorStack(0).getItem(); return helmet == ModItems.GALLIUM_HELMET \u0026amp;\u0026amp; chestplate == ModItems.GALLIUM_CHESTPLATE \u0026amp;\u0026amp; legging == ModItems.GALLIUM_LEGGINGS \u0026amp;\u0026amp; boots == ModItems.GALLIUM_BOOTS; //这里直接判断物品相等 } ··· } 参考文档 Fabric文档：自定义盔甲\n","date":"2025-01-14T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img7.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_7/","title":"MC 1.21.4 盔甲物品注册及相关类详解"},{"content":"参考视频： 工具物品注册时的新写法 我的《在MC1.21.4中创建Item时候遇到的问题》这篇博客中提到了Mojang在 1.21.4版本中要求一个新的Register方法的写法，而工具的注册在原版代码的写法及其register方法如下：\n1 2 3 4 5 6 7 8 9 public class Items { ··· public static final Item WOODEN_SWORD = register(\u0026#34;wooden_sword\u0026#34;, settings -\u0026gt; new SwordItem(ToolMaterial.WOOD, 3.0F, -2.4F, settings)); ··· public static Item register(String id, Function\u0026lt;Item.Settings, Item\u0026gt; factory) { return register(keyOf(id), factory, new Item.Settings()); } ··· } 而一般物品的注册写法和register方法如下：\n1 2 3 4 5 6 7 8 9 public class Items { ··· public static final Item APPLE = register(\u0026#34;apple\u0026#34;, new Item.Settings().food(FoodComponents.APPLE)); ··· public static Item register(String id, Item.Settings settings) { return register(keyOf(id), Item::new, settings); } ··· } 可以看到两个register方法的形参列表不一样，所以我们需要在ModItems中仿制一个register方法。\n我写的如下：\n1 2 3 4 5 6 7 8 public class ModItems { ··· public static Item register(String name, Function\u0026lt;Item.Settings, Item\u0026gt; factory) { final RegistryKey\u0026lt;Item\u0026gt; registryKey = RegistryKey.of(RegistryKeys.ITEM, Identifier.of(\u0026lt;YOURMODID\u0026gt;, name)); return Items.register(registryKey, factory, new Item.Settings()); } ··· } 于是我们注册工具的写法如下：\n1 2 3 4 5 6 7 8 9 10 11 public class ModItems { ··· //这里的SWORD展示了防火（下界合金）写法 public static final Item GA_SWORD = register(\u0026#34;ga_sword\u0026#34;, settings -\u0026gt; new SwordItem(ModToolMaterial.GALLIUM, 3.0F, -2.0F, new Item.Settings() .fireproof() .registryKey(RegistryKey.of(RegistryKeys.ITEM, Identifier.of(\u0026lt;YOURMODID\u0026gt;, \u0026#34;ga_sword\u0026#34;))))); //需要多传递一个.registryKey参数 //PICKAXE是普通写法 public static final Item GA_PICKAXE = register(\u0026#34;ga_pickaxe\u0026#34;, settings -\u0026gt; new PickaxeItem(ModToolMaterial.GALLIUM, 1.5F, -2.8F, settings)); ··· } 但对于GA_SWORD这种有特殊属性的工具，这样写显得代码很难看。但我又发现，不管是普通Item还是工具Item，都定义了一个RegistryKey.of的量，于是我把两个register方法和这里的RegistryKey.of量提出来改写为函数。全部重写后如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ModItems { //普通item注册 public static final Item INGOT_GA = register(\u0026#34;ingot_ga\u0026#34;, Item::new, new Item.Settings()); //工具item注册 public static final Item GA_SWORD = register(\u0026#34;ga_sword\u0026#34;, settings -\u0026gt; new SwordItem(ModToolMaterial.GALLIUM, 3.0F, -2.0F, new Item.Settings() .fireproof() .registryKey(ModregistryKey(\u0026#34;ga_sword\u0026#34;)))); public static final Item GA_PICKAXE = register(\u0026#34;ga_pickaxe\u0026#34;, settings -\u0026gt; new PickaxeItem(ModToolMaterial.GALLIUM, 1.5F, -2.8F, settings)); //工具item注册方法，registryKey被提出 public static Item register(String name, Function\u0026lt;Item.Settings, Item\u0026gt; factory) { return Items.register(ModregistryKey(name), factory, new Item.Settings()); } //普通item注册方法，registryKey被提出 public static Item register(String name, Function\u0026lt;Item.Settings, Item\u0026gt; factory, Item.Settings settings) { return Items.register(ModregistryKey(name), factory, settings); } //RegistryKey.of量的返回方法 private static RegistryKey\u0026lt;Item\u0026gt; ModregistryKey(String name) { return RegistryKey.of(RegistryKeys.ITEM, Identifier.of(\u0026lt;YOURMODID\u0026gt;, name)); } } ToolMaterials类的移除 视频中提到我们需要新建一个自己的ToolMaterials变量来决定工具物品的等级、耐久等，但在1.21.4中，ToolMaterials内被Mojang移除了，但好在ToolMaterials继承自ToolMaterial类，且ToolMaterial是一个record类，具体描述如下：\n\u0026ldquo;Java 14 引入了 record 这一概念，提供了一种简洁的方式来定义包含数据的类。Record 是一种特殊的类，主要用于携带数据，其成员变量是默认 final 的。虽然 record 提高了代码的可读性和简洁性，但有一个重要的特性是，record 不能被继承。这一限制使得 record 在对象模型设计中的角色与传统类有所不同。\u0026rdquo; ——摘自“java record不能被继承”\n所以用子类继承的想法被淘汰了，而ToolMaterial实际上成为了一个可以被定义和初始化的量。\n新建ModToolMaterial类 综上所述，我们只需要新建一个ModToolMaterial的类，然后把这些量定义到这即可。写法如下：\n1 2 3 4 5 6 7 8 9 10 public class ModToolMaterial { public static final ToolMaterial GALLIUM = new ToolMaterial( BlockTags.INCORRECT_FOR_IRON_TOOL,//TagKey\u0026lt;Block\u0026gt; incorrectBlocksForDrops, 1000,//int durability, 7.0F,//float speed, 2.0F,//float attackDamageBonus, 14,//int enchantmentValue, ModItemTags.GALLIUM_TAG//TagKey\u0026lt;Item\u0026gt; repairItems ); } 这里因为反编译的代码和文档提供的不一致，为了方便阅读，每个量给了注释。另外，修复用的物品要求一个ItemTag，所以自己去定义一个Tag（实际上大部分时候你会觉得建一个Tag是Mojang找事的写法）。\n","date":"2025-01-13T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img6.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_6/","title":"MC 1.21.4 中工具物品注册方法及相关类变更详解"},{"content":"使用Plain Craft Launcher 2启动器 下载和解压Plain Craft Launcher 2 首先，打开PCL2（注：Plain Craft Launcher 2以下均简称PCL2或PCL）的官方指定下载网站\nPCL2作者龙腾猫跃的爱发电主页\n有一定实力的朋友可以去给爱发电看看投喂规则以解锁更多PCL2的功能\n然后按如图所示的点击，进入网盘下载PCL2\n选择PCL 正式版 x.x.xx 按图所示解压 （过程不一定一样，取决于你的解压软件）\n（PS：这里偷懒没更新图片，压缩包名字不是HMCL了）\n安装Minecraft 将PCL2启动器复制到自己喜欢的路径，然后双击打开 （必做，MC的安装位置默认取决于这步）\n如果没有正版账号就输入个名字（英文）\n有正版账号就选择正版登录，然后根据启动器的提示进行（有可能需要你在浏览器打开然后粘贴启动器的程序码）\n点击下载游戏 选择自己需要的版本 （这里以1.21.4做演示）\n然后选择需要的插件和插件版本 （不建议在高版本安装OptiFine，这会和大部分Mod冲突，可以去了解一下钠及其附属Mod的优化）\n（关于MOD加载器可以去看文末的描述）\n点击安装 （这里选装Fabric）\n版本隔离说明 这里不建议开启版本隔离（除非你清楚开启后MC目录结构的变化），如果你有玩多个整合包（MC版本）的需要，建议每个版本都按如上流程开一个新文件夹。\n安装完成提示如下： 返回后就可以启动游戏了。\n补充1：关于MOD加载器的演化 Forge和Fabric的拉扯： Minecraft在1.13以后因为重写了大量代码和渲染机制，导致MCP（一种修改MC代码的映射）几乎停摆，这使得自MC1.0版本时代诞生的老牌Mod加载器Forge迟迟未适配新版本，甚至LiteLoader（另一个老牌轻量化Mod加载器，与Forge兼容）直接停更， 为了在新版本中更好的编写Mod，社区诞生了如Rift这种轻量加载器（Fabric前身）， 而这些新的Mod加载器因为映射和接口不一样，加上原来Forge开发的领导者Lex的不配合，导致Forge和Fabric几乎不兼容（即使用了互联mod也是bug不断）。 而Fabric由于其轻量化、高效的Mod加载形式以及其对Mod开发者的友好，导致大量Mod开始转移到Fabric，但复杂的Mod仍然离不开接口更多的Forge。Forge开始衰落。二者的竞争也导致了MC Mod开发的逐渐撕裂这一及其不利好的现象出现（表现为一些Mod不提供另一加载器的版本，导致Mod与Mod之间的组合受到限制）。\nOptifine： 由于MC 1.13渲染机制的重写导致其新版的优化效果下降，加之长期不与Fabric兼容但其却一直与Forge兼容（尽管可以使用其它Mod来强行兼容Fabric，但同样效果不好），而Fabric端的玩家为了优化和开光影，开发出了效果更好的钠+Iris ShadersMod组合。Optifine即使在Forge端，也由于代码闭源使得Mod开发者无法找出与其冲突的原因以及本身的历史遗留问题，导致其在高版本与大量Mod存在严重冲突（导致游戏崩溃），所以不建议在高版本继续使用它 （除非你只用Optifine来优化画质）。\nNeoForge的诞生： \u0026ldquo;NeoForge 的项目开展历程跟 Forge 有关。此前一天，原名为 Forgecord（因 Forge 项目建立） 的 Discord 社区被当时的社区拥有者 cpw 重命名为 NeoForge。 并且因一些原因从而导致原 Forge 开发团队的几乎所有成员都加入了新的团队： NeoForged，只有几个例外：LexManos（Lex，Forge领导人），KingLemming（热力团队负责人），mezz（JEI 作者）， Kristiāns Micītis（原 FTB 领导者、KubeJS 团队人员）。分支的主要原因是团队成员之一的 Lex 从创建了 Forge 项目开始（大约 13 年前） 就一直在社区中表现出严重的负面行为，且 Forge 的大量核心资产由 Lex 的公司 Forge LLC 授权管理。他多次辱骂要求新功能的模组作者， 甚至因为有人询问代码混淆（Mixin）问题而封禁对方。此外，他还涉及性骚扰和恐跨行为。 NeoForge 的开发团队认为，通过分支和品牌重塑能够更好地推进项目发展，并能保护社区。\u0026rdquo; ——引用自MC百科\u0026quot;[Neo]NeoForge\u0026quot;\n出于以上及NeoForge继承于Forge的原因，在1.20.1后大量Forge Mod逐渐也开始转写为NeoForge Mod，而Forge的衰落也几乎成为了必然。 而与原来傲慢的Lex决裂后的NeoForge团队也开始筹划与Fabric的兼容，这让MC Mod的社区和未来的Mod开发有了新的希望。\n总结 Forge和Optifine在MC 1.12.2及以前的版本为玩家们带来了众多的Mod，它陪伴MC走过了一段辉煌的岁月，也铸就了一个以Forge为主导的Mod时代（表现为在那个时代几乎一切的东西都能兼容Forge）。但正如历史上那些一直在原地踏步的事物一样，都注定被时代所淘汰，Forge和Optifine在MC 1.13以后不寻求更高效的Mod加载和注入方法，一昧地抹杀不同于己见者，迫使玩家社区写出Fabric这样新的替代品，可以说，Fabric的诞生几乎是Forge推动的，高傲的Lex终会为他自己的行为付出代价。最后，如果你是或者想成为一个Mod开发者，为了MC Mod社区的未来，请使用Fabric或NeoForge来编写代码。\n补充2：关于游戏的配置详解 注：PCL启动器几乎不需要手动管理游戏内存，但这里还是给出管理内存入口如何进入的教程图\n内存 首先要知道电脑的物理内存（和前面查看系统位数的方法一致） 计算机显示的是 GB，而 HMCL启动器显示的是 MB，因此在修改前要了解进率 1024MB=1GB\n设置内存的一些建议 游戏的内存至少有1024MB（1GB）（32位Java的只支持最高1024MB（1GB））（如果电脑连2048MB（2GB）物理内存都没有，你还是别玩了） 游戏的建议内存最好有4096MB（4GB）（如果自己加了70+的模组，一般建议直接上8192MB（8GB），前提是物理内存比8192MB（8GB）至少大2048MB（2GB）） 注意你的物理内存大小，分配给Minecraft的内存至少比物理内存少2048MB，如果内存不够就不要玩大型模组整合包了 在运行大型模组整合包时，如果需要同时使用OBS或其他录制软件录制视频，物理内存最好为12288 MB (12 GB)或更多，然后为系统保留4096 MB（4GB）的内存 其它设置建议 建议把分辨率设置为 1280*720 （主要因为是16:9的分辨率，方便截图和视频录制） 把启动器设置为 保持启动器可见 （这样方便防止低配电脑退出时卡死，也方便大型模组整合包调试） 如果大型模组整合包启动游戏出问题，可以把查看日志打开（前提你有一定的Java基础） 附：.minecraft目录详解图 （仅供参考）\n","date":"2025-01-11T00:00:00Z","image":"https://zephyrbd.github.io/images/htIsMCN/img3.png","permalink":"https://zephyrbd.github.io/p/howtoinstallminecraft/","title":"如何安装我的世界国际版（新）"},{"content":"参考视频： Mojang为item重写了Model加载方法 我的《在MC1.21.4中创建Item时候遇到的问题》这篇博客中提到了Mojang在 1.21.4版本中要求新建一个这个路径的文件夹，而这就是可以采用新写法的原因。\nassets/\u0026lt;namespace\u0026gt;/items\n这里也是以原版的望远镜为例子，它在该路径下的json文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;model\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;minecraft:select\u0026#34;, \u0026#34;cases\u0026#34;: [ { \u0026#34;model\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;minecraft:model\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;minecraft:item/spyglass\u0026#34; }, \u0026#34;when\u0026#34;: [ \u0026#34;gui\u0026#34;, \u0026#34;ground\u0026#34;, \u0026#34;fixed\u0026#34; ] } ], \u0026#34;fallback\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;minecraft:model\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;minecraft:item/spyglass_in_hand\u0026#34; }, \u0026#34;property\u0026#34;: \u0026#34;minecraft:display_context\u0026#34; } } 不难看出，视频中要求的模型加载和在渲染场景选择的问题被转移到了这个json文件中表达， 这意味着我们可以直接使用ModModelsProvider来进行数据生成，而无需mixin\nModModelsProvider直接生成JSON 在查阅原版代码的时候，发现了在ItemModelGenerator类中注册望远镜模型的办法如下\n1 2 3 4 5 public void register() { ··· this.registerWithInHandModel(Items.SPYGLASS); ··· } 我们又知道\nModModelsProvider继承于FabricModelProvider继承于ItemModelGenerator\n所以我们在ModModelsProvider的generateItemModels方法中直接就可以使用registerWithInHandModel方法\n具体如下：\n1 2 3 4 5 6 7 public class ModModelsProvider extends FabricModelProvider { ··· @Override public void generateItemModels(ItemModelGenerator itemModelGenerator) { itemModelGenerator.registerWithInHandModel(ModItems.PLATE); } } 使用这个函数进行数据生成会在generated文件夹下生成以下内容\nassets\\\u0026lt;yourModID\u0026gt;\\items\\plate.json assets\\\u0026lt;yourModID\u0026gt;\\models\\item\\plate.json 这看起来和使用register方法没有区别，但实际上在 1 路径下的文件结构和上面原版的“望远镜”一样了。\n为了便于区别，这里给一个普通物品的该JSON： 1 2 3 4 5 6 { \u0026#34;model\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;minecraft:model\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;minecraft:item/apple\u0026#34; } } 发现多的\u0026quot;when\u0026quot;正好与视频中的if的条件对应，也就是说只需要修改when中的值，就可以达到与视频中一样控制3D化场景的时候了\n深入剖析registerWithInHandModel方法 这里先贴出原版的函数实现：\n1 2 3 4 5 public final void registerWithInHandModel(Item item) { ItemModel.Unbaked unbaked = ItemModels.basic(this.upload(item, Models.GENERATED)); ItemModel.Unbaked unbaked2 = ItemModels.basic(ModelIds.getItemSubModelId(item, \u0026#34;_in_hand\u0026#34;)); this.output.accept(item, createModelWithInHandVariant(unbaked, unbaked2)); } 可以看到有一个\u0026quot;_in_hand\u0026quot;的字符串，这意味着我们在resources文件夹下的\nassets\\\u0026lt;yourModID\u0026gt;\\models\\item\n添加物品的3D信息JSON的时候，需要把文件名改为item名+_in_hand的形式。\n如plate_in_hand.json\n继续深入看createModelWithInHandVariant方法 还是先给出函数实现：\n1 2 3 4 5 6 7 public static ItemModel.Unbaked createModelWithInHandVariant(ItemModel.Unbaked model, ItemModel.Unbaked inHandModel) { return ItemModels.select( new DisplayContextProperty(), inHandModel, ItemModels.switchCase(List.of(ModelTransformationMode.GUI, ModelTransformationMode.GROUND, ModelTransformationMode.FIXED), model) ); } 你会发现assets\\\u0026lt;yourModID\u0026gt;\\items\\plate.json中的when已经被Mojang写死在这了，所以要实现像视频中那样只在GUI中渲染为2D的话，你需要重写这个方法。 不过还有个简单的形式是你直接去修改生成的JSON文件中的when的值\n（Tip：数据生成在下次运行的时候不会修改你手动改过的文件）\n这样你在1.21.4中就实现了如下效果\n","date":"2025-01-10T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img5.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_5/","title":"1.21.4将2D物品转换为3D的新方法（无需Mixin）"},{"content":"先说说今天的心情 看到Respwan在Apex的今天的更新上继续作死（逆天的给探路者的勾爪改到固定30s的CD，然后改废了TS），这些没母的改动使得陪伴了我3年的游戏就这样彻底的进入了坟墓， 我的心情也是极度的难过， 不知道重生想干什么，也不知道玩家多了对游戏能有什么坏处， 但这种B事就是发生了， 我不得不告别Apex，这里给上@Leamonheadtv的一段话。\nEnglish: Respawn figures out that they don't deserve to have Apex Legends under their development team.lt's embarrassing and a middle finger to actual gamers.\nChinese: 重生对我们的热爱，和对身法的极致追求，竖了一个中指，并叫我们滚蛋\n参考视频： 如果你只是想添加玻璃方块的Tags到配方中，请先看这\nFabircAPI在\nnet.fabricmc.fabric.api.tag.convention.v2.ConventionalItemTags 中提供了GLASS_BLOCKS的标签，直接用就完事。\n后面是我的研究过程\n阶段一：ModItemTagsProvider中构造函数的新写法 1 2 3 public ModItemTagsProvider(FabricDataOutput output, CompletableFuture\u0026lt;RegistryWrapper.WrapperLookup\u0026gt; completableFuture, @Nullable BlockTagProvider blockTagProvider) { super(output, completableFuture, blockTagProvider); } 这样写使得在后面的configure方法中能引入copy函数。\n阶段二：在DataGenerator中重新新建实例 1 2 3 4 5 6 7 8 9 public class ModDataGenerator implements DataGeneratorEntrypoint { @Override public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) { FabricDataGenerator.Pack pack = fabricDataGenerator.createPack(); FabricTagProvider.BlockTagProvider blockTagsProvider = pack.addProvider(ModBlockTagsProvider::new); pack.addProvider((output, completableFuture) -\u0026gt; new ModItemTagsProvider(output, completableFuture, blockTagsProvider)); } } //ModBlockTagsProvider在这里重新定义ModItemTagsProvider被定义了，所以无需单独再定义ModBlockTagsProvider 阶段三：尝试把BlockTags.IMPERMEABLE复制到GLASS_TAG中 1.尝试新建一个自己的BlockTag(GLASS_LIST)来复制BlockTags.IMPERMEABLE； getOrCreateTagBuilder(ModBlockTags.GLASS_LIST).forceAddTag(BlockTags.IMPERMEABLE);\n2. 然后在ModItemTagsProvider使用copy函数复制到自己的ItemTag(GLASS_TAG)中\nthis.copy(ModBlockTags.GLASS_LIST, ModItemTags.GLASS_TAG);\n3. 以上结果在使用recipeProvider生成时没遇到问题，但是游戏运行后结果如下\n[Render thread/ERROR] (Minecraft) Couldn't load tag firstfabricmod:glass_tag as it is missing following references: \u0026lt;#789950127774105602\u0026gt;:impermeable (from firstfabricmod)\n所以配方也是无效的\n阶段四，尝试直接copy BlockTags.IMPERMEABLE 代码如下：\nthis.copy(BlockTags.IMPERMEABLE, ModItemTags.GLASS_TAG);\nGLASS_TAG的json文件生成了，但是values是空的\nJSON文件内容如下：\n1 2 3 { \u0026#34;values\u0026#34;: [] } 总结： BlockTags.IMPERMEABLE貌似是一个特殊的BlockTag标签，即使被copy到ItemTag中也无法正确被游戏使用（至少我们在Discord Fabric的频道中讨论结果是这样的），最后直接使用FabricAPI提供的Tags就好。\n特别感谢以下两位Fabric频道中的高手给予的帮助 @marea\n@𓆩⟡ 𝑵𝐨𝐯𝐚 ⟡𓆪\n参考代码： Github - AppliedEnergistics 2\n","date":"2025-01-08T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img4.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_4/","title":"个人在给探矿器添加配方时遇到的问题"},{"content":"此文章系转载文章\n作者：莱特雷-letere\n来自：莱特雷-letere\u0026rsquo;s Blog\n1 环境准备 Git下载 前往【Git官网】，下载安装程序 一直点下一步，默认安装即可\nHugo下载 前往【Hugo Github Tags】，选择对应版本下载，下载后解压即可 Windows下载版本：hugo_extended_xxxxx_windows_amd64.zip\n2 搭建博客 创建博客 （1）在hugo.exe所在文件夹的地址栏敲打cmd，然后Enter唤起命令行\n（2）敲打命令hugo new site xxxx创建hugo文件\n（3）敲打命名cd xxxx切换目录，并把hugo.exe复制到刚生成的文件夹中\n（4）敲打命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务 （hugo默认是没有主题的，需要进行主题配置）\n配置主题 （1）前往【Hugo Themes】，查找自己喜欢的主题，进行下载\n（2）这边以【Stack主题】为例，将下载好的主题解压，放到/themes文件夹中\n（3）将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content\n（4）修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名\n（5）再次启动hugo服务，查看主题，具体主题配置修改 hugo.yaml，这里不细说，感兴趣可自行查找相关文章\n3 Github部署 常规部署 （1）前往【Github官网】，创建仓库 {github用户名}.github.io\n（2）前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址\n（3）回到hugo文件中，执行命令hugo -D，会生成 public 静态资源文件夹 （4）在 public 执行以下命令上传到github仓库上，第一次上传可能需要输入账号密码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main （5）上传成功后访问 https://{github用户名}.github.io，成功搭建属于自己的Hugo博客 Github Action自动部署 （1）Github创建一个新的仓库，用于存放Hugo的主文件 （2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic)\n（3）token选择永不过期，并勾选 repo 和 workflow 选项\n（4）为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置\n（5）在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy （6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件 1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 4 ZephyrBD个人补充部分 第一次使用git的教程 （1）生成（配置）SSH，打开Git Bash，输入\ngit config --global user.name \u0026quot;注册名\u0026quot; 或者\ngit config --global user.email \u0026quot;注册邮箱\u0026quot;\n（2）生成SSH\nssh-keygen -t rsa -C \u0026quot;自己的邮箱\u0026quot;\n生成成功，如下图所示：\nSSH文件存放在C:/User/用户/.ssh下，id_rsa为私钥，id_rsa.pub为公钥。\n（3）github配置SSH\n打开id_rsa.pub文件，全选，复制全文，转到github-\u0026gt;账户-\u0026gt;setting\n（4）选择SSH and GPGkeys，New SSH key （5）自定义一个title，然后粘贴从公钥文件中拷贝的key （6）测试SSH连接\nssh -T git@github.com 按照提示输入yes，回车，提示successfully之类的就说明SSH连接正常，github上的钥匙也会变成绿色\n至此，本地git客户端和远程github建立了联系。 ","date":"2025-01-04T00:00:00Z","image":"https://zephyrbd.github.io/images/HtbuBlog/img1.png","permalink":"https://zephyrbd.github.io/p/howtobuildablog/","title":"【Hugo】Hugo + Github 免费部署自己的博客"},{"content":"参考视频： 相同与区别 PS.修改了上个笔记不对的地方\n仍然要extends FabricRecipeProvider FabricRecipeProvider要求的实现方法和super函数不一样 generate()方法改在了getRecipeGenerator()方法的return中实现 各种配方的生成函数的形参列表发生改变 ShapedRecipeJsonBuilder.create()方法形参列表变化较大（我没研究明白），所以换成createShaped()方法 上述方法的.offerTo()方法第二个参数变为RegistryKey\u0026lt;\u0026gt;类型，所以Identifier.of()如下面这样嵌套，Identifier.of()中填写的参数和视频一致 Example Identifier: RegistryKey.of(RegistryKeys.RECIPE, getRecipeIdentifier( Identifier_HERE );\n这里代码的合成物品以镓矿系列为例子\nExample All: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class ModRecipesProvider extends FabricRecipeProvider { private static final List\u0026lt;ItemConvertible\u0026gt; GA_FURNACE = List.of(ModItems.example_item); public ModRecipesProvider(FabricDataOutput output, CompletableFuture\u0026lt;RegistryWrapper.WrapperLookup\u0026gt; registriesFuture) { super(output, registriesFuture); } @Override protected RecipeGenerator getRecipeGenerator(RegistryWrapper.WrapperLookup wrapperLookup, RecipeExporter recipeExporter) { return new RecipeGenerator(wrapperLookup, recipeExporter) { public void generate() { //可逆配方 offerReversibleCompactingRecipes(RecipeCategory.MISC, ModItems.INGOT_GA, RecipeCategory.BUILDING_BLOCKS, ModBlocks.GA_BLOCK); //熔炉 offerSmelting(GA_FURNACE, RecipeCategory.MISC, ModItems.INGOT_GA, 0.7f, 200, \u0026#34;ga_blast_furnace\u0026#34;); //高炉 offerBlasting(GA_FURNACE, RecipeCategory.MISC, ModItems.INGOT_GA, 0.7f, 100, \u0026#34;ga_blast_furnace\u0026#34;); //烟熏炉 offerFoodCookingRecipe(\u0026#34;smoking\u0026#34;, RecipeSerializer.SMOKING, SmokingRecipe::new,600, ModItems.RAW_GA, ModItems.INGOT_GA, 0.35f); //篝火 offerFoodCookingRecipe(\u0026#34;campfire_cooking\u0026#34;, RecipeSerializer.CAMPFIRE_COOKING, CampfireCookingRecipe::new,600, ModItems.RAW_GA, ModItems.INGOT_GA, 0.35f); //有序配方 createShaped(RecipeCategory.MISC, ModItems.GA_EXAMPLE) .pattern(\u0026#34;XXX\u0026#34;) .input(\u0026#39;X\u0026#39;,ModItems.INGOT_GA) .criterion(\u0026#34;has_ga_example\u0026#34;,conditionsFromItem(ModItems.INGOT_GA)) .offerTo(exporter, RegistryKey.of(RegistryKeys.RECIPE, getRecipeIdentifier(Identifier.of(\u0026lt;yourMODID\u0026gt;, \u0026#34;ga_example\u0026#34;)))); //无序配方 createShapeless(RecipeCategory.MISC, Items.FLINT_AND_STEEL,1) .input(ModItems.INGOT_GA) .input(Items.IRON_INGOT) .criterion(\u0026#34;has_flint_steel\u0026#34;,conditionsFromItem(ModItems.INGOT_GA)) .criterion(\u0026#34;has_flint_steel\u0026#34;,conditionsFromItem(Items.IRON_INGOT)) .offerTo(exporter,RegistryKey.of(RegistryKeys.RECIPE, getRecipeIdentifier(Identifier.of(\u0026lt;yourMODID\u0026gt;, \u0026#34;other_flint_and_steel\u0026#34;)))); } }; } @Override public String getName() { return \u0026lt;yourMODID\u0026gt;; } } 参考代码： Issue #4252 · FabricMC/fabric Waystones/../datagen/ModRecipeProvider.java ","date":"2025-01-02T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img2.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_2/","title":"在1.21.4中创建ModRecipesProvider类的相同与区别 V2.0"},{"content":"参考视频： 这里补充一下我在1.21.4中遇到的问题\nregister方法新形式 1.21.2以后的item的register方法要写成下面这种新的形式：\n1 2 3 4 5 6 7 8 9 10 public class ModItems { public static final Item CUSTOM_ITEM = register(\u0026#34;custom_item\u0026#34;, Item::new, new Item.Settings()); public static Item register(String path, Function\u0026lt;Item.Settings, Item\u0026gt; factory, Item.Settings settings) { final RegistryKey\u0026lt;Item\u0026gt; registryKey = RegistryKey.of(RegistryKeys.ITEM, Identifier.of(\u0026#34;tutorial\u0026#34;, path)); return Items.register(registryKey, factory, settings); } public static void initialize() { } } PS：进阶写法参见《MC 1.21.4 中工具物品注册方法及相关类变更详解》\n并且除了添加lang、models.item和textures.item文件夹及其对应json以外，要使得材质正常显示还需添加这样一个文件夹和对应的json。\nassets/\u0026lt;namespace\u0026gt;/items\n参考： 关于1.21.4的fabric中创建item的更改内容(即新的json需要的写法)具体见：here\nFabric中文wiki（关于在1.21.2后创建一个item的方法参见）：here\n","date":"2025-01-02T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img1.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_1/","title":"在MC1.21.4中创建Item时候遇到的问题"},{"content":"参考视频： 相同与区别 (PS：Bugjump是真能改)\n仍然要创建一个FoodComponent类 FoodComponent类弃用了snack()、statusEffect()、createStew()等方法 药水效果需要通过ConsumableComponents类来实现 由于2,3，需要创建一个ModFoodConsumableComponents的新类 由于4，在register该食物Item时可能会需要传一个ModFoodConsumableComponents.XXX的参数 在register该食物Item时可以用useRemainder(BOWL)来实现归还碗的效果 文件结构如图：\n这里以EXAMPLE_SOUP为例子\nModItems: 1 2 3 4 5 6 7 8 9 10 11 public class ModItems { public static final Item EXAMPLE_SOUP = register(\u0026#34;example_soup\u0026#34;, Item::new, new Item.Settings() .maxCount(1) .food(ModFoodComponents.EXAMPLE_SOUP,ModFoodConsumableComponents.EXAMPLE_SOUP) //food两个参数，ModFoodComponents.XXX是食物的普通数值和属性 //ModFoodConsumableComponents.XXX是食物给予的药水效果等属性 //这里的XXX要与后面两个类中名称一致 .useRemainder(BOWL));//归还玩家一个碗 ... } ModFoodComponents： 1 2 3 4 5 6 public class ModFoodComponents { //使用alwaysEdible()将使得食物始终可以食用 public static final FoodComponent EXAMPLE_SOUP = new FoodComponent.Builder().nutrition(2).saturationModifier(0.3F).alwaysEdible().build(); ... } ModFoodConsumableComponents: 1 2 3 4 5 6 7 8 9 10 public class ModFoodConsumableComponents { //药水效果需要放到一个StatusEffectInstance类型的List中,但我这没开单独的容器 public static final ConsumableComponent EXAMPLE_SOUP = food().consumeEffect(new ApplyEffectsConsumeEffect(List.of( new StatusEffectInstance(StatusEffects.REGENERATION, 100, 1), new StatusEffectInstance(StatusEffects.ABSORPTION, 2400, 0), new StatusEffectInstance(StatusEffects.FIRE_RESISTANCE, 2400, 0)))) .build(); ... } ","date":"2025-01-02T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img3.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_3/","title":"在MC1.21.4中创建食物的相同与区别"},{"content":"Github开源地址 仓库链接\n智记清单（MCZS To Do）项目说明 一、项目概述 智记清单是一款专为大学生和打工人设计的待办清单程序。它具备提醒功能，能有效帮助用户合理安排事务，其界面直观简洁，易于操作。在设计上充分考虑了用户的时间管理需求及使用体验，还通过随时间变化的背景为程序增添了趣味性。\n二、设计思路 背景与痛点：初入大学或职场，事务繁杂易遗忘重要事项，且多数人在事务安排上缺乏经验。 功能需求分析： 提醒功能：满足学习、社团等活动的提醒需求。 今日待办：让用户清晰知晓当天任务。 易上手：方便新建和管理待办事项。 程序规划： 数据存储模块：运用 json 文件、对象和数组保存用户提醒任务详情，确保数据持久化与高效读写。 数据交互模块：作为模块间数据桥梁，保障程序流畅运行与协同工作。 界面模块：呈现可视化界面，方便用户交互操作。 提醒功能模块：实现提醒逻辑，包括时间设定、触发机制与多种提醒方式。 三、关键技术 json 和结构体应用：通过 todoINFO 结构体数组存放待办事项内容，利用 todoToJson 函数在关闭程序时将结构体转化为 json 对象存盘，借助 jsonArray 管理多个 json 对象，程序打开时用 jsonToTodo 函数转回结构体并添加到 Qlist 容器便于操作。 Qt 框架开发： 信号与槽机制：实现高效对象间事件通信，如设置待办事项点击确认按钮时新建结构体变量，逻辑清晰且代码耦合度低。 布局管理：多种布局管理器确保界面在不同电脑上视觉与操作良好。 类库资源：丰富类库用于创建各类可视化组件，如 QPushButton 类创建按钮。 用户体验支持：如实现背景切换动画，增强趣味性与体验感。 四、作品特色 提醒功能：借助 Windows 系统通知，在 Qtimer 定时器检测下，以醒目的系统通知弹出提醒事项内容与地点。\n背景切换：利用 QDateTime 变量、Qtimer 定时器和 Switch-case 结构实现一天内背景随时间切换壁纸，且有多组可选。 图形化界面：基于 Qt 框架打造，布局合理、按钮一目了然，易于上手操作。 五、项目信息 团队成员： 项目主导及核心代码：ZephyrBD JSON 转换方法：puuuuh 指导老师：CUIT计算机学院老师 版权与开源： 提交给学校的 Alpha 1.0 版本用于特定比赛，请勿外泄。（Github的Releases中的Alpha 1.0版本为公共版） 除背景图片组版权属于美国苹果公司外，其余内容遵循大赛共享协议，现在以 GPL - 2.0 协议开源到该 Github 仓库。 项目文件：包含 MCZS_TO_DO.pro、头文件（如 aboutus.h 等）、源文件（如 aboutus.cpp 等）、界面文件（如 aboutus.ui 等）、资源文件 res.qrc 及其他文件 version.rc。 ","date":"2025-01-02T00:00:00Z","image":"https://zephyrbd.github.io/images/cuitDRace/img1.png","permalink":"https://zephyrbd.github.io/p/cuitappdesignrace/","title":"智记清单（MCZS To Do）Alpha 1.0 发布"},{"content":"为什么MC 1.17 需要使用 Java 16 MC自从1.8就开始使用Java 8，到现在已经用了8个大版本了。mojang也决定从MC 1.17开始使用最近才发布的Java 16（官方给出的解释是有更好的优化，但我觉得应该是mojang用了Java 16的新语法），总的来说，这一举动是好的。\n对玩家有什么影响 显然，过去我们使用Java 8来打开MC，现在Java 8是不可能打开1.17了，那是不是把旧的Java删除就可以了？当然不行，旧版的Java可以帮助我们打开旧的MC版本，删除后就只可以玩1.17了，下面就讲述如何使Java 8和16共存。\n更新步骤一：更新启动器 在我的教程《如何安装Minecraft国际版》已经介绍了HMCL启动器的安装，现在就以HMCL启动器为例，讲述启动器的更新。 1.打开启动器，注意右上角的提示 2.点击它，看到下图所示界面 可以看到自从HMCL 3.3.184开始就支持Java 16了，不过考虑到兼容性，还是推荐更新到最新版（会有更新提示），现在点击右下角的更新出现下图所示界面。 表明开始更新，更新完成后会自动重启，然后就可以看到HMCL版本和刚才更新日志的版本一致了。 视频讲解 视频中是个简单方法，成功了就可以不看后面了（但启动器必须更新） 更新步骤二：Java 16和MC 1.17的安装 1.检测电脑位数\n这个我在如何安装Minecraft国际版已经讲了，不知道的可以去看看。 2.下载Java 16 64位点我 32位点我 3.解压下载的文件并且拷贝到MC文件夹 4.选择版本列表，然后点安装新游戏版本 选择1.17 选择Optifine 选择最新版本 Optifine选择成功后如图所示，然后点击安装 更新步骤三：MC 1.17启动前设置 1.安装成功后如图所示，点击设置 2.勾选启用游戏特定设置 3.选择Java 16的路径（按照图示界面点击） 有关其它的设置可以参考《如何安装Minecraft国际版》里面的讲解。 4.返回并启动游戏 以上自己安装Java 16的教程可以参考下面这个视频 ","date":"2021-06-24T00:00:00Z","image":"https://zephyrbd.github.io/images/htjava/img1.png","permalink":"https://zephyrbd.github.io/p/howtoupdatejava/","title":"如何更新到Java-16"},{"content":"为什么要端口映射？ 现在大部分人的宽带IP地址都是运营商分配给我们的，但一般情况下只会给我们内网IP地址，举个例子：10个人要上网，但10个公网IP太多了，那么就让10个人共用一个“网关”，再由“网关”联网，这样10个人就只用掉一个IP，但我的世界联机的时候，别人和你不在一个“网关”之下，那他就只可以找到你的“网关”，而不知道10个人中那个是你，这个时候就需要一个“中间人”来告诉他你到底是谁，然后你们就可以一起愉快玩耍了，这个“中间人”就是第三方服务器映射的IP\n如何进行端口映射 1.注册SAKURA FRP账号 SAKURA FRP是一个免费的端口映射网站，可以帮我们进行映射，打开网站后界面如图所示。 点击注册账号进行注册（注意：使用 中国大陆节点 必须完成实名认证）进入后如图所示。 2.下载SAKURA FRP客户端 点击上图所示的左侧边栏上的软件下载，打开后按图示点击，或者点我下载客户端 3.安装SAKURA FRP启动器并打开 回到官网，在管理面板上复制访问密钥 回到启动器粘贴并登陆 4.转发端口 打开需要联机的世界，选择对局域网开放 添加一个隧道（找到java那个，没有的话刷新一下，然后选择一个合适的转发服务器，点击创建） 打开隧道就可以了（弹出的提示框中的IP就是你朋友用的） 注意：本方法仅适用于正版玩家\n","date":"2021-03-13T00:00:00Z","image":"https://zephyrbd.github.io/images/htgoon/img1.png","permalink":"https://zephyrbd.github.io/p/howtousetheinternationalversionofminecrafttogoonline/","title":"如何使用国际版我的世界进行联机"},{"content":"为什么突然写这个 当下OLED屏幕弯折角度越来越大，再者之前看到了一个回形针做的一个关于曲面屏的视频，我不由得产生了一个想法——那就是用柔性屏做一个符合但又不局限于传统书本概念的书，所以接下来我就好好的说一下这个想法（本文仅仅阐述我这个概念性的想法，喷子勿看）\n怎样做才像一本书 ①书写 一本传统概念的书，首先要做的就是书写，这大多数电子产品都可以，但书写的体验我敢说绝对不如在真正的纸上书写，所以，我要探索的不仅仅是普通的书本书写，更要舒适的书写，现在能做到在OLED屏幕上写字就像在真纸上的，我只知道两个口碑不错的产品：\n苹果的Apple Pencil 华为的M-Pencil 在这方面，苹果要做的比华为早，书写的体验也是目前业界的佼佼者，假设这本书拥有Apple Pencil的技术，再加上几十块钱的书写膜，那写得舒服的这个问题就解决了，体验也能像这个视频一样。 ②弯折 一本传统的概念书籍来说，能做的第二件事就是正常的弯折，所以上面我提到了这样的OLED屏幕。 虽然这样可以弯折了，但仅仅只能翻折一次，所以要使用Galaxy Fold制作的方法来制造，但这也会使它像Galaxy Fold那样留下无法抹去的折痕，以及这个巨大的弯折半径。 看到这些照片后，相信你也会意识到这些问题都是无法忍受的，但是有一项新技术——ULP-NSSP，可以很好地解决这个问题，就像柔宇科技这个屏幕。 再次假设这本书拥有ULP-NSSP工艺制成的OLED屏幕，折痕和弯折半径的问题也将被解决。\n技术下的新功能 目前已实现了传统图书的功能，现在谈谈未来图书的功能。\n①增强现实（AR）和激光雷达扫描仪 借助于性能强劲的 CPU，比如高通骁龙处理器，再加上4800万像素以上的摄像头，实现了如下图所示的增强现实。 甚至像下面这样通过局域网连接来实现多台设备同时使用一个增强现实场景，这对教育方面将会有巨大的影响，试想老师通过AR技术讲解生物，物理，化学等科目所需演示的实验和模型，那是一件多么不可思议的事情啊！ 以及激光雷达扫描仪 激光雷达 (LiDAR 光探测和测距) 这项先进技术，是通过测量光触及物体并反射回来所需的时间，来确定距离。特制的激光雷达扫描仪利用直接飞行时间 (dToF)，测量室内或室外环境中从最远五米处反射回来的光。 它可从光子层面进行探测，并能以纳秒速度运行，为增强现实及更广泛的领域开启无尽可能。\n②文档的转换和在电子文档上书写 未来的书，当然不能仅仅是一本书，它应该是像上面那样，可以从网上购买各种书籍的版权，而不必支付印刷费用，这将对地球的环境保护做出巨大贡献，而且借助前文提到的强大的书写系统，就可以像阅读真书一般。\n甚至当做笔记本来使用，当你正处在课堂上时，第一个工作区可以查看课本，而第二个工作区用来充当笔记本（工作区后文会介绍），将教科书中的一段话截屏放进笔记本中，再做上注释，这很好地解决了学生记笔记的痛苦， 也可以把第二个工作区设置为练习册和参考书等辅助资料，从此学生的桌面上不再有成堆书本，取而代之的是一本这样的书。\n③多个可拆卸的屏幕和防盗技术 这本书应该有两个屏幕，其中一块是和处理器之类固定在书上的屏幕，另一块则可随意拆卸，为了方便解释，我用纸质笔记本来简单描述一下。 与此同时它还具有下图中的防盗功能，就像现在的手机一般，对丢失的设备进行远程定位、锁定、备份和删除，在保证个人资料安全的同时，也一定程度上解决了书本找不到的问题。 本文阐述了我对未来书籍的一些想法，但是我认为未来肯定不会止步于此，我也希望将来会有更多更好的科技产品服务于我们的生活。。\n资料来源 Apple Pencil—Apple中国\n增强现实—Apple中国\niPad Pro—Apple中国\niCloud—Apple中国\nHUAWEI M-Pencil 套装—华为官网\n柔宇科技—OLED屏幕\n2017 Apple 秋季发布会\n2018 Apple 秋季发布会\n回形针PaperClip—你究竟需要怎样的屏幕？\n","date":"2020-10-03T00:00:00Z","image":"https://zephyrbd.github.io/images/fubook/img1.png","permalink":"https://zephyrbd.github.io/p/thefuturebooks/","title":"我对未来书本的一个设想"},{"content":"安装Java（必须，游戏依赖） 1.查看电脑系统位数 右键此电脑（或者叫计算机或这台电脑），选择属性，如图所示（图片仅供参考） 记住系统位数，一会用得上\n2.打开下载Java的链接 32位系统版本点我\n64位系统版本点我\n下载完成后打开，一直下一步安装完成就可以了（安装成功截图如下） 使用Hello Minecraft Launcher启动器 1.下载和解压Hello Minecraft Launcher 首先，打开HMCL（注：Hello Minecraft Launcher以下均简称HMCL）在mcbbs的帖子，点击如图所示的链接（HMCL官网链接好像挂了，演示时先暂时用百度网盘分享） 为了方便，这里我把网盘链接拿过来了，不过还是建议去原贴下载。\n百度网盘下载地址 提取码: g4hd\n然后按如图所示的点击：\n选择HMCL版本 选择自己的系统（看不懂就选Windows） 打钩后下载 按图所示解压（过程不一定一样，取决于你的解压软件） 2.安装Minecraft 将HMCL启动器复制到自己喜欢的路径，然后双击打开 如果没有正版账号就输入个名字（最好英文） 有正版账号就选择正版登录 选择版本列表，然后点安装新游戏版本 选择自己需要的版本（这里以1.16.3做演示） 然后选择需要的插件和插件版本（强烈建议安装OptiFine，可以减轻渲染的负担，也可以不安装任何插件）（演示时安装OptiFine） 点击安装 安装完成后如图所示 返回后就可以启动游戏了 补充：关于游戏的配置详解 按图示进入配置页面 内存 首先要知道电脑的物理内存（和前面查看系统位数的方法一致） 计算机显示的是 GB，而 HMCL启动器显示的是 MB，因此在修改前要了解进率 1024MB=1GB\n设置内存的一些建议 游戏的内存至少有1024MB（1GB）（32位Java的只支持最高1024MB（1GB））（如果电脑连2048MB（2GB）物理内存都没有，你还是别玩了） 游戏的建议内存最好有4096MB（4GB）（如果自己加了70+的模组，一般建议直接上8192MB（8GB），前提是物理内存比8192MB（8GB）至少大2048MB（2GB）） 注意你的物理内存大小，分配给Minecraft的内存至少比物理内存少2048MB，如果内存不够就不要玩大型模组整合包了 在运行大型模组整合包时，如果需要同时使用OBS或其他录制软件录制视频，物理内存最好为12288 MB (12 GB)或更多，然后为系统保留4096 MB（4GB）的内存 其它设置建议 建议把分辨率设置为 1280*720 （主要因为是16:9的分辨率，方便截图和视频录制） 把启动器设置为 保持启动器可见 （这样方便防止低配电脑退出时卡死，也方便大型模组整合包调试） 如果大型模组整合包启动游戏出问题，可以把查看日志打开（前提你有一定的Java基础） 附：.minecraft目录详解图（仅供参考） ","date":"2020-09-20T00:00:00Z","image":"https://zephyrbd.github.io/images/htIsMC/img1.png","permalink":"https://zephyrbd.github.io/p/howtoinstallminecraft_old/","title":"如何安装我的世界国际版"}]