[{"content":"变量定义和赋值 变量的概念 什么是变量： 变量是编程中的基本概念，用于存储数据和在程序中进行各种操作。它们是程序中用于保存和处理信息的“容器”。\n变量的作用：\n存储数据： 变量可以存储用户输入的数据、计算结果、中间数据等。例如，用户输入的年龄、计算出的总和、读取的文件内容等都可以存储在变量中。 引用数据： 通过变量名可以在程序的不同部分引用或访问存储的数据。变量名是对存储在内存中数据的引用。 类型灵活： 在 Python 中，变量可以存储各种类型的数据，如整数、浮点数、字符串、列表、字典等。 PS：在Python中，定义变量基本变量一般不给出变量类型的定义，Python会自动根据变量被赋的值进行判断。\n变量赋值 将数据放入变量保存的过程叫做赋值\nPS:\n这里的等号=叫做赋值运算符。 所有的编程语言都是用=作为赋值运算符。 python中，变量的定义和赋值是在一条语句中实现的。 =的左边叫做左值，=的右边叫做右值。 1 2 3 4 age = 17 # 给变量赋值 age = 18 # 具体的值 age1 = age # 变量 age2 = age + 1 # 表达式 一个变量被声明后，在其后的代码中就可以使用了，可以参与运算，可以赋值给其他变量，也可以作为参数传给某个函数。\n变量的命名规则 在编程中，变量的命名规则非常重要，遵守这些规则可以避免语法错误，并提高代码的可读性和可维护性。以下是 Python 变量命名时必须遵守的规则：\n变量名由字母、数字和下划线组成 变量名只能包含 字母（a-z, A-Z）、数字（0-9） 和 下划线（_）。 Python 区分大小写，因此 name 和 Name 是两个不同的变量。 Example:\n1 2 3 name = \u0026#34;ZehyrBD\u0026#34; # 正确 _age = 19 # 正确 ffl = 1.35 # 正确 变量名不能以数字开头 变量名必须以字母或下划线开头，不能以数字开头。 Example:\n1 2 1sex = 99 # 错误，不能数字开头 sex1 = 99 # 正确，数字在字母之后 变量名不能是 Python 的关键字 Python 的关键字是保留用于特殊用途的单词，不能用作变量名 Example:\n1 2 def = 100 # 错误，\u0026#39;def\u0026#39; 是关键字 for = 200 # 错误，\u0026#39;for\u0026#39; 是关键字 Python中的关键字(保留字) 关键字（或保留字）是 Python 内部设计时预留的具有特定功能的单词。这些关键字在 Python 代码中具有特殊含义，用来表示特定的操作或语法结构。因此，关键字不能被用作变量名、函数名或任何其他标识符，否则会导致语法错误。\n如何查看 Python 的关键字列表 Python 提供了一个内置的 keyword 模块，可以用来查看当前版本 Python 中的所有关键字。你可以使用以下代码来打印出这些关键字： 1 2 import keyword print(keyword.kwlist) 当你运行上面的代码时，将会输出 Python 当前版本中所有的关键字列表。以下是 Python 3中的关键字示例：\n1 2 3 4 5 [\u0026#39;False\u0026#39;, \u0026#39;None\u0026#39;, \u0026#39;True\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;as\u0026#39;, \u0026#39;assert\u0026#39;, \u0026#39;async\u0026#39;, \u0026#39;await\u0026#39;, \u0026#39;break\u0026#39;, \u0026#39;class\u0026#39;, \u0026#39;continue\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;del\u0026#39;, \u0026#39;elif\u0026#39;, \u0026#39;else\u0026#39;, \u0026#39;except\u0026#39;, \u0026#39;finally\u0026#39;, \u0026#39;for\u0026#39;, \u0026#39;from\u0026#39;, \u0026#39;global\u0026#39;, \u0026#39;if\u0026#39;, \u0026#39;import\u0026#39;, \u0026#39;in\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;lambda\u0026#39;, \u0026#39;nonlocal\u0026#39;, \u0026#39;not\u0026#39;, \u0026#39;or\u0026#39;, \u0026#39;pass\u0026#39;, \u0026#39;raise\u0026#39;, \u0026#39;return\u0026#39;, \u0026#39;try\u0026#39;, \u0026#39;while\u0026#39;, \u0026#39;with\u0026#39;, \u0026#39;yield\u0026#39;] Python 关键字列表解析 以下是一些常用关键字及其基本功能： 控制流关键字： if, elif, else：用于条件判断。 for, while：用于循环。 break, continue：用于控制循环的执行。 try, except, finally, raise：用于异常处理。 定义和声明关键字： def：用于定义函数。 class：用于定义类。 lambda：用于定义匿名函数。 import, from：用于导入模块。 逻辑运算关键字： and, or, not：用于逻辑运算。 is, in：用于比较运算。 其他常见关键字： return：用于从函数返回值。 yield：用于生成器函数，返回一个值并暂停函数的执行。 global, nonlocal：用于声明变量的作用域。 True, False, None：布尔值和空值。 注意事项 无需死记硬背：Python 的关键字数量有限（大约 35 个），这些关键字会在你编写代码时频繁使用。虽然刚开始可能需要查询关键字的具体功能，但随着编程经验的积累，你会逐渐熟悉这些关键字，并自然记住它们。因此，不需要刻意去死记硬背，反复练习和实际编程会帮助你掌握它们。 避免使用关键字作为变量名：如果不小心使用了关键字作为变量名，Python 会报语法错误。\n例如： 1 if = 5 # 这是非法的，会导致语法错误 关键字是区分大小写的：例如，True 是关键字，但 true 不是关键字，可以作为变量名使用。 通过理解并熟悉这些关键字，你将能够更有效地编写 Python 代码。随着编程经验的增长，你会逐渐内化这些关键字的用法。\n变量命名风格的建议（规范） 在遵守变量命名规则的前提下，变量的命名尽量要见名知意，一般使用英文单词，忌用拼音\n见名知意\n变量的命名应尽量清晰明确，能够反映其用途或包含的数据。避免使用与实际用途不符的名字。 Good Example：\n1 2 3 name = \u0026#34;ZephyrBD\u0026#34; # 变量名清楚地表明其保存的是名字 age = 20 # 变量名清楚地表明其保存的是年龄 total_price = 100 # 变量名清楚地表明其保存的是总价 Bad Example：\n1 2 3 mingzi = \u0026#34;ZephyrBD\u0026#34; # 使用拼音命名，容易引起困惑，不符合国际化编程习惯 mz = \u0026#34;ZephyrBD\u0026#34; # 变量名过于简短，无法清楚表达含义 tp = 100 # 变量名不清晰，不易理解其含义 使用英文单词\n尽量使用标准的英文单词来命名变量，而不是拼音或缩写。这能提高代码的可读性。 Good Example：\n1 2 height = 180 # 使用英文单词 birth_date = \u0026#34;1990-01-01\u0026#34; Bad Example：\n1 2 gao = 180 # 使用拼音，不利于他人理解 birthD = \u0026#34;1990-01-01\u0026#34; # 使用缩写，容易造成混淆 使用下划线分隔单词（蛇形命名法 | 下划线命名法）\n对于多个单词组成的变量名，使用下划线 _ 分隔每个单词，以增强可读性。这种命名方式称为“蛇形命名法”（snake_case），是 Python 社区推荐的命名风格。 Good Example：\n1 2 first_name = \u0026#34;John\u0026#34; # 单词之间使用下划线分隔 total_amount = 500 Bad Example：\n1 2 firstname = \u0026#34;John\u0026#34; # 单词直接连接，降低可读性 totalAmount = 500 # 使用驼峰命名法，不符合 Python 规范 避免使用保留字和内置函数名\n不要使用 Python 的保留字或内置函数名作为变量名，以免引起错误或困惑。\n保留字：if, else, while, for, class, try, except, import, from 等。 内置函数名：list, str, int, sum, print, len 等。 Good Example：\n1 2 my_list = [1, 2, 3] # 避免与内置函数名 `list` 冲突 count = 10 # 避免使用 `sum` 作为变量名 Bad Example：\n1 2 list = [1, 2, 3] # 覆盖了内置函数 `list` sum = 10 # 覆盖了内置函数 `sum` 保持命名风格一致 在同一个项目或模块中，保持变量命名风格的一致性非常重要。不要混合使用不同的命名风格（如蛇形命名法与驼峰命名法）。 Good Example：\n1 2 3 user_name = \u0026#34;Alice\u0026#34; user_age = 30 total_amount = 1000 Bad Example：\n1 2 3 userName = \u0026#34;Alice\u0026#34; # 驼峰命名法 user_age = 30 # 蛇形命名法 totalAmount = 1000 # 驼峰命名法 变量命名长度适中 变量名不宜过长或过短，过长会影响书写和阅读，过短则不利于理解。命名时，应在表达清晰和简洁之间取得平衡。 Good Example：\n1 2 product_name = \u0026#34;Laptop\u0026#34; # 长度适中，含义明确 price = 999 # 简短且清晰 Bad Example：\n1 2 p = 999 # 过于简短，含义不明确 name_of_the_product_we_sold = \u0026#34;Laptop\u0026#34; # 过长，冗余 通过遵循这些变量命名的建议和规范，可以大大提高代码的可读性、可维护性和专业性。这是非常重要的。\n注释和字符 注释 代码注释是为了提高代码的可读性和维护性。通过注释，在代码中记录下有关代码逻辑、目的、使用方法等信息，方便自己或其他人在后续的代码维护和修改过程中理解代码的意图\n单行注释：采用 # 开头， 表示这一行的内容是注释，不会被 Python 解释器执行 1 2 # 定义变量 x 并赋值为 10 x = 10 多行注释：使用三个引号（\u0026lsquo;\u0026lsquo;\u0026lsquo;注释\u0026rsquo;\u0026rsquo;\u0026rsquo; 或 \u0026ldquo;\u0026ldquo;\u0026ldquo;注释\u0026rdquo;\u0026quot;\u0026quot;）包裹 1 2 3 4 \u0026#34;\u0026#34;\u0026#34; 这是一个多行注释 可以用于较长的说明 \u0026#34;\u0026#34;\u0026#34; Docstring（文档字符串） ：文档字符串是 Python 特有的一种注释方式，通常用于函数、类或模块的说明。文档字符串也是使用三个引号包裹，但它们是用来生成文档的，而不仅仅是注释 1 2 3 4 5 6 7 8 9 10 11 12 def add(a, b): \u0026#34;\u0026#34;\u0026#34; 这个函数用于两个数字的加法运算。 参数: a -- 第一个加数 b -- 第二个加数 返回值: 两个加数的和 \u0026#34;\u0026#34;\u0026#34; return a + b Tips：\n注释应尽量简洁明了，描述清楚代码的意图。 对于复杂的代码逻辑，建议使用详细的注释，以帮助理解代码。 注释和代码之间保持适当的空白，以提高可读性 字符串 字符串是 Python 中一种非常重要的数据类型，用于表示和处理文本信息。字符串可以使用单引号、双引号或者三引号来定义，具体的选择取决于你所处理的文本内容。下面详细介绍字符串的各种定义方式及其使用方法。\n单引号、双引号定义单行字符串 1 2 3 4 name = \u0026#34;ZephyrBD” desc = \u0026#34;好好学习，天天向上\u0026#34; # 使用单引号和双引号进行字符串定义没有任何区别。 # 当单引号是字符串的一部分时用双引号定义字符串，反之亦然。 2、 三引号定义多行字符串定义（字符串跨行的时候使用）\n1 2 3 4 5 info = \u0026#34;\u0026#34;\u0026#34; 一大段多行字符串 第二行，bababa 第三行，6666 \u0026#34;\u0026#34;\u0026#34; PS：\n代码中所有的标点符号都要用英文格式的 字符串中有单引号时（外面得双引号包裹） 字符串中有双引号时（外面得单引号包裹） ","date":"2025-01-19T00:00:00Z","image":"https://zephyrbd.github.io/images/Pydev/dev2/img0.png","permalink":"https://zephyrbd.github.io/p/pythondev_2/","title":"变量的定义、注释和字符详解"},{"content":"参考视频： 盔甲注册的新方法 同\u0026quot;《MC 1.21.4 中工具物品注册方法及相关类变更详解》\u0026ldquo;这篇博客中所写的register方法大致一样，这里给个例子：\n1 2 3 public class ModItems { public static final Item GA_HELMET = register(\u0026#34;ga_helmet\u0026#34;, settings -\u0026gt; new ArmorItem(ModArmorMaterials.GALLIUM_ARMOR, EquipmentType.HELMET, settings)); } ModArmorMaterials类的变化 好消息：你Mojang又把这ModArmorMaterials改回interface（接口）了（真是活母操作）！\n于是你只需要新建一个接口类然后定义变量就好了。具体例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 public interface ModArmorMaterials { ArmorMaterial GALLIUM = new ArmorMaterial(20, Util.make(new EnumMap(EquipmentType.class), map -\u0026gt; { map.put(EquipmentType.BOOTS, 3); map.put(EquipmentType.LEGGINGS, 6); map.put(EquipmentType.CHESTPLATE, 8); map.put(EquipmentType.HELMET, 3); map.put(EquipmentType.BODY, 11); }), 10, SoundEvents.ITEM_ARMOR_EQUIP_IRON, 2.0F, 0.0F, ModItemTags.GALLIUM_TAG, ModEquipmentAssetKeys.GALLIUM); //SoundEvents.ITEM_ARMOR_EQUIP_IRON表示穿戴音效 //ModItemTags.GALLIUM_TAG表示修复材料 //ModEquipmentAssetKeys.GALLIUM表示装备穿戴的时候渲染相关的量（我不确定） } ModEquipmentAssetKeys类 这个是表示装备穿戴的时候渲染相关的量（我不确定），总之也是个接口类，写上如下变量：\n1 2 3 4 5 6 public interface ModEquipmentAssetKeys { RegistryKey\u0026lt;EquipmentAsset\u0026gt; GALLIUM = register(\u0026#34;gallium\u0026#34;); static RegistryKey\u0026lt;EquipmentAsset\u0026gt; register(String name) { return RegistryKey.of(REGISTRY_KEY, Identifier.of(\u0026lt;YOURMODID\u0026gt;,name)); } } PS：注意MOD_ID（这玩意卡了我半天，甚至还去Discord问了，结果是直接用了原版的方法发现原版写的是Identifier.ofVanilla(name)，淦！）。\n盔甲材质文件目录的变更 这里先给出老版本目录第三人称盔甲材质的目录结构：\n/main/resources/assets/\u0026lt;YOURMODID\u0026gt;/textures/models/armor/\n然后新版本改到了：\n/main/resources/assets/\u0026lt;YOURMODID\u0026gt;/textures/entity/equipment/humanoid 和\n/main/resources/assets/\u0026lt;YOURMODID\u0026gt;/textures/entity/equipment/humanoid_leggings下\n此外你还需要在： /main/resources/assets/\u0026lt;YOURMODID\u0026gt;/equipment下新建一个json，\n名字格式为RegistryKey\u0026lt;EquipmentAsset\u0026gt;变量名\n内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;layers\u0026#34;: { \u0026#34;humanoid\u0026#34;: [ { \u0026#34;texture\u0026#34;: \u0026#34;firstfabricmod:gallium\u0026#34; } ], \u0026#34;humanoid_leggings\u0026#34;: [ { \u0026#34;texture\u0026#34;: \u0026#34;firstfabricmod:gallium\u0026#34; } ] } } 注：这里省了马铠的声明，具体见原版的json。\ngetMaterial()方法的移除 Mojang移除了Item类中的getMaterial()方法，这导致在后面实现穿戴盔甲时给予玩家药水效果时不能用ExampleHelmet.getMaterial() = YourMaterial这样的句子，于是我直接改用了如下判断：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ModArmorItem extends ArmorItem { ··· private boolean hasCorrectArmorSet(PlayerEntity player) { Item helmet = player.getInventory().getArmorStack(3).getItem(); Item chestplate = player.getInventory().getArmorStack(2).getItem(); Item legging = player.getInventory().getArmorStack(1).getItem(); Item boots = player.getInventory().getArmorStack(0).getItem(); return helmet == ModItems.GALLIUM_HELMET \u0026amp;\u0026amp; chestplate == ModItems.GALLIUM_CHESTPLATE \u0026amp;\u0026amp; legging == ModItems.GALLIUM_LEGGINGS \u0026amp;\u0026amp; boots == ModItems.GALLIUM_BOOTS; //这里直接判断物品相等 } ··· } 参考文档 Fabric文档：自定义盔甲\n","date":"2025-01-14T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img7.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_7/","title":"MC 1.21.4 盔甲物品注册及相关类详解"},{"content":"参考视频： 工具物品注册时的新写法 我的《在MC1.21.4中创建Item时候遇到的问题》这篇博客中提到了Mojang在 1.21.4版本中要求一个新的Register方法的写法，而工具的注册在原版代码的写法及其register方法如下：\n1 2 3 4 5 6 7 8 9 public class Items { ··· public static final Item WOODEN_SWORD = register(\u0026#34;wooden_sword\u0026#34;, settings -\u0026gt; new SwordItem(ToolMaterial.WOOD, 3.0F, -2.4F, settings)); ··· public static Item register(String id, Function\u0026lt;Item.Settings, Item\u0026gt; factory) { return register(keyOf(id), factory, new Item.Settings()); } ··· } 而一般物品的注册写法和register方法如下：\n1 2 3 4 5 6 7 8 9 public class Items { ··· public static final Item APPLE = register(\u0026#34;apple\u0026#34;, new Item.Settings().food(FoodComponents.APPLE)); ··· public static Item register(String id, Item.Settings settings) { return register(keyOf(id), Item::new, settings); } ··· } 可以看到两个register方法的形参列表不一样，所以我们需要在ModItems中仿制一个register方法。\n我写的如下：\n1 2 3 4 5 6 7 8 public class ModItems { ··· public static Item register(String name, Function\u0026lt;Item.Settings, Item\u0026gt; factory) { final RegistryKey\u0026lt;Item\u0026gt; registryKey = RegistryKey.of(RegistryKeys.ITEM, Identifier.of(\u0026lt;YOURMODID\u0026gt;, name)); return Items.register(registryKey, factory, new Item.Settings()); } ··· } 于是我们注册工具的写法如下：\n1 2 3 4 5 6 7 8 9 10 11 public class ModItems { ··· //这里的SWORD展示了防火（下界合金）写法 public static final Item GA_SWORD = register(\u0026#34;ga_sword\u0026#34;, settings -\u0026gt; new SwordItem(ModToolMaterial.GALLIUM, 3.0F, -2.0F, new Item.Settings() .fireproof() .registryKey(RegistryKey.of(RegistryKeys.ITEM, Identifier.of(\u0026lt;YOURMODID\u0026gt;, \u0026#34;ga_sword\u0026#34;))))); //需要多传递一个.registryKey参数 //PICKAXE是普通写法 public static final Item GA_PICKAXE = register(\u0026#34;ga_pickaxe\u0026#34;, settings -\u0026gt; new PickaxeItem(ModToolMaterial.GALLIUM, 1.5F, -2.8F, settings)); ··· } 但对于GA_SWORD这种有特殊属性的工具，这样写显得代码很难看。但我又发现，不管是普通Item还是工具Item，都定义了一个RegistryKey.of的量，于是我把两个register方法和这里的RegistryKey.of量提出来改写为函数。全部重写后如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ModItems { //普通item注册 public static final Item INGOT_GA = register(\u0026#34;ingot_ga\u0026#34;, Item::new, new Item.Settings()); //工具item注册 public static final Item GA_SWORD = register(\u0026#34;ga_sword\u0026#34;, settings -\u0026gt; new SwordItem(ModToolMaterial.GALLIUM, 3.0F, -2.0F, new Item.Settings() .fireproof() .registryKey(ModregistryKey(\u0026#34;ga_sword\u0026#34;)))); public static final Item GA_PICKAXE = register(\u0026#34;ga_pickaxe\u0026#34;, settings -\u0026gt; new PickaxeItem(ModToolMaterial.GALLIUM, 1.5F, -2.8F, settings)); //工具item注册方法，registryKey被提出 public static Item register(String name, Function\u0026lt;Item.Settings, Item\u0026gt; factory) { return Items.register(ModregistryKey(name), factory, new Item.Settings()); } //普通item注册方法，registryKey被提出 public static Item register(String name, Function\u0026lt;Item.Settings, Item\u0026gt; factory, Item.Settings settings) { return Items.register(ModregistryKey(name), factory, settings); } //RegistryKey.of量的返回方法 private static RegistryKey\u0026lt;Item\u0026gt; ModregistryKey(String name) { return RegistryKey.of(RegistryKeys.ITEM, Identifier.of(\u0026lt;YOURMODID\u0026gt;, name)); } } ToolMaterials类的移除 视频中提到我们需要新建一个自己的ToolMaterials变量来决定工具物品的等级、耐久等，但在1.21.4中，ToolMaterials内被Mojang移除了，但好在ToolMaterials继承自ToolMaterial类，且ToolMaterial是一个record类，具体描述如下：\n\u0026ldquo;Java 14 引入了 record 这一概念，提供了一种简洁的方式来定义包含数据的类。Record 是一种特殊的类，主要用于携带数据，其成员变量是默认 final 的。虽然 record 提高了代码的可读性和简洁性，但有一个重要的特性是，record 不能被继承。这一限制使得 record 在对象模型设计中的角色与传统类有所不同。\u0026rdquo; ——摘自“java record不能被继承”\n所以用子类继承的想法被淘汰了，而ToolMaterial实际上成为了一个可以被定义和初始化的量。\n新建ModToolMaterial类 综上所述，我们只需要新建一个ModToolMaterial的类，然后把这些量定义到这即可。写法如下：\n1 2 3 4 5 6 7 8 9 10 public class ModToolMaterial { public static final ToolMaterial GALLIUM = new ToolMaterial( BlockTags.INCORRECT_FOR_IRON_TOOL,//TagKey\u0026lt;Block\u0026gt; incorrectBlocksForDrops, 1000,//int durability, 7.0F,//float speed, 2.0F,//float attackDamageBonus, 14,//int enchantmentValue, ModItemTags.GALLIUM_TAG//TagKey\u0026lt;Item\u0026gt; repairItems ); } 这里因为反编译的代码和文档提供的不一致，为了方便阅读，每个量给了注释。另外，修复用的物品要求一个ItemTag，所以自己去定义一个Tag（实际上大部分时候你会觉得建一个Tag是Mojang找事的写法）。\n","date":"2025-01-13T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img6.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_6/","title":"MC 1.21.4 中工具物品注册方法及相关类变更详解"},{"content":"使用Plain Craft Launcher 2启动器 下载和解压Plain Craft Launcher 2 首先，打开PCL2（注：Plain Craft Launcher 2以下均简称PCL2或PCL）的官方指定下载网站\nPCL2作者龙腾猫跃的爱发电主页\n有一定实力的朋友可以去给爱发电看看投喂规则以解锁更多PCL2的功能\n然后按如图所示的点击，进入网盘下载PCL2\n选择PCL 正式版 x.x.xx 按图所示解压 （过程不一定一样，取决于你的解压软件）\n（PS：这里偷懒没更新图片，压缩包名字不是HMCL了）\n安装Minecraft 将HMCL启动器复制到自己喜欢的路径，然后双击打开 （必做，MC的安装位置默认取决于这步）\n如果没有正版账号就输入个名字（英文）\n有正版账号就选择正版登录，然后根据启动器的提示进行（有可能需要你在浏览器打开然后粘贴启动器的程序码）\n点击下载游戏 选择自己需要的版本 （这里以1.21.4做演示）\n然后选择需要的插件和插件版本 （不建议在高版本安装OptiFine，这会和大部分Mod冲突，可以去了解一下钠及其附属Mod的优化）\n（关于MOD加载器可以去看文末的描述）\n点击安装 （这里选装Fabric）\n版本隔离说明 这里不建议开启版本隔离（除非你清楚开启后MC目录结构的变化），如果你有玩多个整合包（MC版本）的需要，建议每个版本都按如上流程开一个新文件夹。\n安装完成提示如下： 返回后就可以启动游戏了。\n补充1：关于MOD加载器的演化 Forge和Fabric的拉扯： Minecraft在1.13以后因为重写了大量代码和渲染机制，导致MCP（一种修改MC代码的映射）几乎停摆，这使得自MC1.0版本时代诞生的老牌Mod加载器Forge迟迟未适配新版本，甚至LiteLoader（另一个老牌轻量化Mod加载器，与Forge兼容）直接停更， 为了在新版本中更好的编写Mod，社区诞生了如Rift这种轻量加载器（Fabric前身）， 而这些新的Mod加载器因为映射和接口不一样，加上原来Forge开发的领导者Lex的不配合，导致Forge和Fabric几乎不兼容（即使用了互联mod也是bug不断）。 而Fabric由于其轻量化、高效的Mod加载形式以及其对Mod开发者的友好，导致大量Mod开始转移到Fabric，但复杂的Mod仍然离不开接口更多的Forge。Forge开始衰落。二者的竞争也导致了MC Mod开发的逐渐撕裂这一及其不利好的现象出现（表现为一些Mod不提供另一加载器的版本，导致Mod与Mod之间的组合受到限制）。\nOptifine： 由于MC 1.13渲染机制的重写导致其新版的优化效果下降，加之长期不与Fabric兼容但其却一直与Forge兼容（尽管可以使用其它Mod来强行兼容Fabric，但同样效果不好），而Fabric端的玩家为了优化和开光影，开发出了效果更好的钠+Iris ShadersMod组合。Optifine即使在Forge端，也由于代码闭源使得Mod开发者无法找出与其冲突的原因以及本身的历史遗留问题，导致其在高版本与大量Mod存在严重冲突（导致游戏崩溃），所以不建议在高版本继续使用它 （除非你只用Optifine来优化画质）。\nNeoForge的诞生： \u0026ldquo;NeoForge 的项目开展历程跟 Forge 有关。此前一天，原名为 Forgecord（因 Forge 项目建立） 的 Discord 社区被当时的社区拥有者 cpw 重命名为 NeoForge。 并且因一些原因从而导致原 Forge 开发团队的几乎所有成员都加入了新的团队： NeoForged，只有几个例外：LexManos（Lex，Forge领导人），KingLemming（热力团队负责人），mezz（JEI 作者）， Kristiāns Micītis（原 FTB 领导者、KubeJS 团队人员）。分支的主要原因是团队成员之一的 Lex 从创建了 Forge 项目开始（大约 13 年前） 就一直在社区中表现出严重的负面行为，且 Forge 的大量核心资产由 Lex 的公司 Forge LLC 授权管理。他多次辱骂要求新功能的模组作者， 甚至因为有人询问代码混淆（Mixin）问题而封禁对方。此外，他还涉及性骚扰和恐跨行为。 NeoForge 的开发团队认为，通过分支和品牌重塑能够更好地推进项目发展，并能保护社区。\u0026rdquo; ——引用自MC百科\u0026quot;[Neo]NeoForge\u0026quot;\n出于以上及NeoForge继承于Forge的原因，在1.20.1后大量Forge Mod逐渐也开始转写为NeoForge Mod，而Forge的衰落也几乎成为了必然。 而与原来傲慢的Lex决裂后的NeoForge团队也开始筹划与Fabric的兼容，这让MC Mod的社区和未来的Mod开发有了新的希望。\n总结 Forge和Optifine在MC 1.12.2及以前的版本为玩家们带来了众多的Mod，它陪伴MC走过了一段辉煌的岁月，也铸就了一个以Forge为主导的Mod时代（表现为在那个时代几乎一切的东西都能兼容Forge）。但正如历史上那些一直在原地踏步的事物一样，都注定被时代所淘汰，Forge和Optifine在MC 1.13以后不寻求更高效的Mod加载和注入方法，一昧地抹杀不同于己见者，迫使玩家社区写出Fabric这样新的替代品，可以说，Fabric的诞生几乎是Forge推动的，高傲的Lex终会为他自己的行为付出代价。最后，如果你是或者想成为一个Mod开发者，为了MC Mod社区的未来，请使用Fabric或NeoForge来编写代码。\n补充2：关于游戏的配置详解 注：PCL启动器几乎不需要手动管理游戏内存，但这里还是给出管理内存入口如何进入的教程图\n内存 首先要知道电脑的物理内存（和前面查看系统位数的方法一致） 计算机显示的是 GB，而 HMCL启动器显示的是 MB，因此在修改前要了解进率 1024MB=1GB\n设置内存的一些建议 游戏的内存至少有1024MB（1GB）（32位Java的只支持最高1024MB（1GB））（如果电脑连2048MB（2GB）物理内存都没有，你还是别玩了） 游戏的建议内存最好有4096MB（4GB）（如果自己加了70+的模组，一般建议直接上8192MB（8GB），前提是物理内存比8192MB（8GB）至少大2048MB（2GB）） 注意你的物理内存大小，分配给Minecraft的内存至少比物理内存少2048MB，如果内存不够就不要玩大型模组整合包了 在运行大型模组整合包时，如果需要同时使用OBS或其他录制软件录制视频，物理内存最好为12288 MB (12 GB)或更多，然后为系统保留4096 MB（4GB）的内存 其它设置建议 建议把分辨率设置为 1280*720 （主要因为是16:9的分辨率，方便截图和视频录制） 把启动器设置为 保持启动器可见 （这样方便防止低配电脑退出时卡死，也方便大型模组整合包调试） 如果大型模组整合包启动游戏出问题，可以把查看日志打开（前提你有一定的Java基础） 附：.minecraft目录详解图 （仅供参考）\n","date":"2025-01-11T00:00:00Z","image":"https://zephyrbd.github.io/images/htIsMCN/img3.png","permalink":"https://zephyrbd.github.io/p/howtoinstallminecraft/","title":"如何安装我的世界国际版（新）"},{"content":"参考视频： Mojang为item重写了Model加载方法 我的《在MC1.21.4中创建Item时候遇到的问题》这篇博客中提到了Mojang在 1.21.4版本中要求新建一个这个路径的文件夹，而这就是可以采用新写法的原因。\nassets/\u0026lt;namespace\u0026gt;/items\n这里也是以原版的望远镜为例子，它在该路径下的json文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;model\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;minecraft:select\u0026#34;, \u0026#34;cases\u0026#34;: [ { \u0026#34;model\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;minecraft:model\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;minecraft:item/spyglass\u0026#34; }, \u0026#34;when\u0026#34;: [ \u0026#34;gui\u0026#34;, \u0026#34;ground\u0026#34;, \u0026#34;fixed\u0026#34; ] } ], \u0026#34;fallback\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;minecraft:model\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;minecraft:item/spyglass_in_hand\u0026#34; }, \u0026#34;property\u0026#34;: \u0026#34;minecraft:display_context\u0026#34; } } 不难看出，视频中要求的模型加载和在渲染场景选择的问题被转移到了这个json文件中表达， 这意味着我们可以直接使用ModModelsProvider来进行数据生成，而无需mixin\nModModelsProvider直接生成JSON 在查阅原版代码的时候，发现了在ItemModelGenerator类中注册望远镜模型的办法如下\n1 2 3 4 5 public void register() { ··· this.registerWithInHandModel(Items.SPYGLASS); ··· } 我们又知道\nModModelsProvider继承于FabricModelProvider继承于ItemModelGenerator\n所以我们在ModModelsProvider的generateItemModels方法中直接就可以使用registerWithInHandModel方法\n具体如下：\n1 2 3 4 5 6 7 public class ModModelsProvider extends FabricModelProvider { ··· @Override public void generateItemModels(ItemModelGenerator itemModelGenerator) { itemModelGenerator.registerWithInHandModel(ModItems.PLATE); } } 使用这个函数进行数据生成会在generated文件夹下生成以下内容\nassets\\\u0026lt;yourModID\u0026gt;\\items\\plate.json assets\\\u0026lt;yourModID\u0026gt;\\models\\item\\plate.json 这看起来和使用register方法没有区别，但实际上在 1 路径下的文件结构和上面原版的“望远镜”一样了。\n为了便于区别，这里给一个普通物品的该JSON： 1 2 3 4 5 6 { \u0026#34;model\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;minecraft:model\u0026#34;, \u0026#34;model\u0026#34;: \u0026#34;minecraft:item/apple\u0026#34; } } 发现多的\u0026quot;when\u0026quot;正好与视频中的if的条件对应，也就是说只需要修改when中的值，就可以达到与视频中一样控制3D化场景的时候了\n深入剖析registerWithInHandModel方法 这里先贴出原版的函数实现：\n1 2 3 4 5 public final void registerWithInHandModel(Item item) { ItemModel.Unbaked unbaked = ItemModels.basic(this.upload(item, Models.GENERATED)); ItemModel.Unbaked unbaked2 = ItemModels.basic(ModelIds.getItemSubModelId(item, \u0026#34;_in_hand\u0026#34;)); this.output.accept(item, createModelWithInHandVariant(unbaked, unbaked2)); } 可以看到有一个\u0026quot;_in_hand\u0026quot;的字符串，这意味着我们在resources文件夹下的\nassets\\\u0026lt;yourModID\u0026gt;\\models\\item\n添加物品的3D信息JSON的时候，需要把文件名改为item名+_in_hand的形式。\n如plate_in_hand.json\n继续深入看createModelWithInHandVariant方法 还是先给出函数实现：\n1 2 3 4 5 6 7 public static ItemModel.Unbaked createModelWithInHandVariant(ItemModel.Unbaked model, ItemModel.Unbaked inHandModel) { return ItemModels.select( new DisplayContextProperty(), inHandModel, ItemModels.switchCase(List.of(ModelTransformationMode.GUI, ModelTransformationMode.GROUND, ModelTransformationMode.FIXED), model) ); } 你会发现assets\\\u0026lt;yourModID\u0026gt;\\items\\plate.json中的when已经被Mojang写死在这了，所以要实现像视频中那样只在GUI中渲染为2D的话，你需要重写这个方法。 不过还有个简单的形式是你直接去修改生成的JSON文件中的when的值\n（Tip：数据生成在下次运行的时候不会修改你手动改过的文件）\n这样你在1.21.4中就实现了如下效果\n","date":"2025-01-10T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img5.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_5/","title":"1.21.4将2D物品转换为3D的新方法（无需Mixin）"},{"content":"先说说今天的心情 看到Respwan在Apex的今天的更新上继续作死（逆天的给探路者的勾爪改到固定30s的CD，然后改废了TS），这些没母的改动使得陪伴了我3年的游戏就这样彻底的进入了坟墓， 我的心情也是极度的难过， 不知道重生想干什么，也不知道玩家多了对游戏能有什么坏处， 但这种B事就是发生了， 我不得不告别Apex，这里给上@Leamonheadtv的一段话。\nEnglish: Respawn figures out that they don't deserve to have Apex Legends under their development team.lt's embarrassing and a middle finger to actual gamers.\nChinese: 重生对我们的热爱，和对身法的极致追求，竖了一个中指，并叫我们滚蛋\n参考视频： 如果你只是想添加玻璃方块的Tags到配方中，请先看这\nFabircAPI在\nnet.fabricmc.fabric.api.tag.convention.v2.ConventionalItemTags 中提供了GLASS_BLOCKS的标签，直接用就完事。\n后面是我的研究过程\n阶段一：ModItemTagsProvider中构造函数的新写法 1 2 3 public ModItemTagsProvider(FabricDataOutput output, CompletableFuture\u0026lt;RegistryWrapper.WrapperLookup\u0026gt; completableFuture, @Nullable BlockTagProvider blockTagProvider) { super(output, completableFuture, blockTagProvider); } 这样写使得在后面的configure方法中能引入copy函数。\n阶段二：在DataGenerator中重新新建实例 1 2 3 4 5 6 7 8 9 public class ModDataGenerator implements DataGeneratorEntrypoint { @Override public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) { FabricDataGenerator.Pack pack = fabricDataGenerator.createPack(); FabricTagProvider.BlockTagProvider blockTagsProvider = pack.addProvider(ModBlockTagsProvider::new); pack.addProvider((output, completableFuture) -\u0026gt; new ModItemTagsProvider(output, completableFuture, blockTagsProvider)); } } //ModBlockTagsProvider在这里重新定义ModItemTagsProvider被定义了，所以无需单独再定义ModBlockTagsProvider 阶段三：尝试把BlockTags.IMPERMEABLE复制到GLASS_TAG中 1.尝试新建一个自己的BlockTag(GLASS_LIST)来复制BlockTags.IMPERMEABLE； getOrCreateTagBuilder(ModBlockTags.GLASS_LIST).forceAddTag(BlockTags.IMPERMEABLE);\n2. 然后在ModItemTagsProvider使用copy函数复制到自己的ItemTag(GLASS_TAG)中\nthis.copy(ModBlockTags.GLASS_LIST, ModItemTags.GLASS_TAG);\n3. 以上结果在使用recipeProvider生成时没遇到问题，但是游戏运行后结果如下\n[Render thread/ERROR] (Minecraft) Couldn't load tag firstfabricmod:glass_tag as it is missing following references: \u0026lt;#789950127774105602\u0026gt;:impermeable (from firstfabricmod)\n所以配方也是无效的\n阶段四，尝试直接copy BlockTags.IMPERMEABLE 代码如下：\nthis.copy(BlockTags.IMPERMEABLE, ModItemTags.GLASS_TAG);\nGLASS_TAG的json文件生成了，但是values是空的\nJSON文件内容如下：\n1 2 3 { \u0026#34;values\u0026#34;: [] } 总结： BlockTags.IMPERMEABLE貌似是一个特殊的BlockTag标签，即使被copy到ItemTag中也无法正确被游戏使用（至少我们在Discord Fabric的频道中讨论结果是这样的），最后直接使用FabricAPI提供的Tags就好。\n特别感谢以下两位Fabric频道中的高手给予的帮助 @marea\n@𓆩⟡ 𝑵𝐨𝐯𝐚 ⟡𓆪\n参考代码： Github - AppliedEnergistics 2\n","date":"2025-01-08T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img4.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_4/","title":"个人在给探矿器添加配方时遇到的问题"},{"content":"此文章系转载文章\n作者：莱特雷-letere\n来自：莱特雷-letere\u0026rsquo;s Blog\n1 环境准备 Git下载 前往【Git官网】，下载安装程序 一直点下一步，默认安装即可\nHugo下载 前往【Hugo Github Tags】，选择对应版本下载，下载后解压即可 Windows下载版本：hugo_extended_xxxxx_windows_amd64.zip\n2 搭建博客 创建博客 （1）在hugo.exe所在文件夹的地址栏敲打cmd，然后Enter唤起命令行\n（2）敲打命令hugo new site xxxx创建hugo文件\n（3）敲打命名cd xxxx切换目录，并把hugo.exe复制到刚生成的文件夹中\n（4）敲打命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务 （hugo默认是没有主题的，需要进行主题配置）\n配置主题 （1）前往【Hugo Themes】，查找自己喜欢的主题，进行下载\n（2）这边以【Stack主题】为例，将下载好的主题解压，放到/themes文件夹中\n（3）将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content\n（4）修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名\n（5）再次启动hugo服务，查看主题，具体主题配置修改 hugo.yaml，这里不细说，感兴趣可自行查找相关文章\n3 Github部署 常规部署 （1）前往【Github官网】，创建仓库 {github用户名}.github.io\n（2）前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址\n（3）回到hugo文件中，执行命令hugo -D，会生成 public 静态资源文件夹 （4）在 public 执行以下命令上传到github仓库上，第一次上传可能需要输入账号密码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main （5）上传成功后访问 https://{github用户名}.github.io，成功搭建属于自己的Hugo博客 Github Action自动部署 （1）Github创建一个新的仓库，用于存放Hugo的主文件 （2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic)\n（3）token选择永不过期，并勾选 repo 和 workflow 选项\n（4）为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置\n（5）在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy （6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件 1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 4 ZephyrBD个人补充部分 第一次使用git的教程 （1）生成（配置）SSH，打开Git Bush，输入\ngit config --global user.name \u0026quot;注册名\u0026quot; 或者\ngit config --global user.email \u0026quot;注册邮箱\u0026quot;\n（2）生成SSH\nssh-keygen -t rsa -C \u0026quot;自己的邮箱\u0026quot;\n生成成功，如下图所示：\nSSH文件存放在C:/User/用户/.ssh下，id_rsa为私钥，id_rsa.pub为公钥。\n（3）github配置SSH\n打开id_rsa.pub文件，全选，复制全文，转到github-\u0026gt;账户-\u0026gt;setting\n（4）选择SSH and GPGkeys，New SSH key （5）自定义一个title，然后粘贴从公钥文件中拷贝的key （6）测试SSH连接\nssh -T git@github.com 按照提示输入yes，回车，提示successfully之类的就说明SSH连接正常，github上的钥匙也会变成绿色\n至此，本地git客户端和远程github建立了联系。 ","date":"2025-01-04T00:00:00Z","image":"https://zephyrbd.github.io/images/HtbuBlog/img1.png","permalink":"https://zephyrbd.github.io/p/howtobuildablog/","title":"【Hugo】Hugo + Github 免费部署自己的博客"},{"content":"参考视频： 相同与区别 PS.修改了上个笔记不对的地方\n仍然要extends FabricRecipeProvider FabricRecipeProvider要求的实现方法和super函数不一样 generate()方法改在了getRecipeGenerator()方法的return中实现 各种配方的生成函数的形参列表发生改变 ShapedRecipeJsonBuilder.create()方法形参列表变化较大（我没研究明白），所以换成createShaped()方法 上述方法的.offerTo()方法第二个参数变为RegistryKey\u0026lt;\u0026gt;类型，所以Identifier.of()如下面这样嵌套，Identifier.of()中填写的参数和视频一致 Example Identifier: RegistryKey.of(RegistryKeys.RECIPE, getRecipeIdentifier( Identifier_HERE );\n这里代码的合成物品以镓矿系列为例子\nExample All: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class ModRecipesProvider extends FabricRecipeProvider { private static final List\u0026lt;ItemConvertible\u0026gt; GA_FURNACE = List.of(ModItems.example_item); public ModRecipesProvider(FabricDataOutput output, CompletableFuture\u0026lt;RegistryWrapper.WrapperLookup\u0026gt; registriesFuture) { super(output, registriesFuture); } @Override protected RecipeGenerator getRecipeGenerator(RegistryWrapper.WrapperLookup wrapperLookup, RecipeExporter recipeExporter) { return new RecipeGenerator(wrapperLookup, recipeExporter) { public void generate() { //可逆配方 offerReversibleCompactingRecipes(RecipeCategory.MISC, ModItems.INGOT_GA, RecipeCategory.BUILDING_BLOCKS, ModBlocks.GA_BLOCK); //熔炉 offerSmelting(GA_FURNACE, RecipeCategory.MISC, ModItems.INGOT_GA, 0.7f, 200, \u0026#34;ga_blast_furnace\u0026#34;); //高炉 offerBlasting(GA_FURNACE, RecipeCategory.MISC, ModItems.INGOT_GA, 0.7f, 100, \u0026#34;ga_blast_furnace\u0026#34;); //烟熏炉 offerFoodCookingRecipe(\u0026#34;smoking\u0026#34;, RecipeSerializer.SMOKING, SmokingRecipe::new,600, ModItems.RAW_GA, ModItems.INGOT_GA, 0.35f); //篝火 offerFoodCookingRecipe(\u0026#34;campfire_cooking\u0026#34;, RecipeSerializer.CAMPFIRE_COOKING, CampfireCookingRecipe::new,600, ModItems.RAW_GA, ModItems.INGOT_GA, 0.35f); //有序配方 createShaped(RecipeCategory.MISC, ModItems.GA_EXAMPLE) .pattern(\u0026#34;XXX\u0026#34;) .input(\u0026#39;X\u0026#39;,ModItems.INGOT_GA) .criterion(\u0026#34;has_ga_example\u0026#34;,conditionsFromItem(ModItems.INGOT_GA)) .offerTo(exporter, RegistryKey.of(RegistryKeys.RECIPE, getRecipeIdentifier(Identifier.of(\u0026lt;yourMODID\u0026gt;, \u0026#34;ga_example\u0026#34;)))); //无序配方 createShapeless(RecipeCategory.MISC, Items.FLINT_AND_STEEL,1) .input(ModItems.INGOT_GA) .input(Items.IRON_INGOT) .criterion(\u0026#34;has_flint_steel\u0026#34;,conditionsFromItem(ModItems.INGOT_GA)) .criterion(\u0026#34;has_flint_steel\u0026#34;,conditionsFromItem(Items.IRON_INGOT)) .offerTo(exporter,RegistryKey.of(RegistryKeys.RECIPE, getRecipeIdentifier(Identifier.of(\u0026lt;yourMODID\u0026gt;, \u0026#34;other_flint_and_steel\u0026#34;)))); } }; } @Override public String getName() { return \u0026lt;yourMODID\u0026gt;; } } 参考代码： Issue #4252 · FabricMC/fabric Waystones/../datagen/ModRecipeProvider.java ","date":"2025-01-02T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img2.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_2/","title":"在1.21.4中创建ModRecipesProvider类的相同与区别 V2.0"},{"content":"参考视频： 这里补充一下我在1.21.4中遇到的问题\nregister方法新形式 1.21.2以后的item的register方法要写成下面这种新的形式：\n1 2 3 4 5 6 7 8 9 10 public class ModItems { public static final Item CUSTOM_ITEM = register(\u0026#34;custom_item\u0026#34;, Item::new, new Item.Settings()); public static Item register(String path, Function\u0026lt;Item.Settings, Item\u0026gt; factory, Item.Settings settings) { final RegistryKey\u0026lt;Item\u0026gt; registryKey = RegistryKey.of(RegistryKeys.ITEM, Identifier.of(\u0026#34;tutorial\u0026#34;, path)); return Items.register(registryKey, factory, settings); } public static void initialize() { } } PS：进阶写法参见《MC 1.21.4 中工具物品注册方法及相关类变更详解》\n并且除了添加lang、models.item和textures.item文件夹及其对应json以外，要使得材质正常显示还需添加这样一个文件夹和对应的json。\nassets/\u0026lt;namespace\u0026gt;/items\n参考： 关于1.21.4的fabric中创建item的更改内容(即新的json需要的写法)具体见：here\nFabric中文wiki（关于在1.21.2后创建一个item的方法参见）：here\n","date":"2025-01-02T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img1.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_1/","title":"在MC1.21.4中创建Item时候遇到的问题"},{"content":"参考视频： 相同与区别 (PS：Bugjump是真能改)\n仍然要创建一个FoodComponent类 FoodComponent类弃用了snack()、statusEffect()、createStew()等方法 药水效果需要通过ConsumableComponents类来实现 由于2,3，需要创建一个ModFoodConsumableComponents的新类 由于4，在register该食物Item时可能会需要传一个ModFoodConsumableComponents.XXX的参数 在register该食物Item时可以用useRemainder(BOWL)来实现归还碗的效果 文件结构如图：\n这里以EXAMPLE_SOUP为例子\nModItems: 1 2 3 4 5 6 7 8 9 10 11 public class ModItems { public static final Item EXAMPLE_SOUP = register(\u0026#34;example_soup\u0026#34;, Item::new, new Item.Settings() .maxCount(1) .food(ModFoodComponents.EXAMPLE_SOUP,ModFoodConsumableComponents.EXAMPLE_SOUP) //food两个参数，ModFoodComponents.XXX是食物的普通数值和属性 //ModFoodConsumableComponents.XXX是食物给予的药水效果等属性 //这里的XXX要与后面两个类中名称一致 .useRemainder(BOWL));//归还玩家一个碗 ... } ModFoodComponents： 1 2 3 4 5 6 public class ModFoodComponents { //使用alwaysEdible()将使得食物始终可以食用 public static final FoodComponent EXAMPLE_SOUP = new FoodComponent.Builder().nutrition(2).saturationModifier(0.3F).alwaysEdible().build(); ... } ModFoodConsumableComponents: 1 2 3 4 5 6 7 8 9 10 public class ModFoodConsumableComponents { //药水效果需要放到一个StatusEffectInstance类型的List中,但我这没开单独的容器 public static final ConsumableComponent EXAMPLE_SOUP = food().consumeEffect(new ApplyEffectsConsumeEffect(List.of( new StatusEffectInstance(StatusEffects.REGENERATION, 100, 1), new StatusEffectInstance(StatusEffects.ABSORPTION, 2400, 0), new StatusEffectInstance(StatusEffects.FIRE_RESISTANCE, 2400, 0)))) .build(); ... } ","date":"2025-01-02T00:00:00Z","image":"https://zephyrbd.github.io/images/MCFDev/img3.png","permalink":"https://zephyrbd.github.io/p/firstfabricmoddevlog_3/","title":"在MC1.21.4中创建食物的相同与区别"},{"content":"Github开源地址 仓库链接\n智记清单（MCZS To Do）项目说明 一、项目概述 智记清单是一款专为大学生和打工人设计的待办清单程序。它具备提醒功能，能有效帮助用户合理安排事务，其界面直观简洁，易于操作。在设计上充分考虑了用户的时间管理需求及使用体验，还通过随时间变化的背景为程序增添了趣味性。\n二、设计思路 背景与痛点：初入大学或职场，事务繁杂易遗忘重要事项，且多数人在事务安排上缺乏经验。 功能需求分析： 提醒功能：满足学习、社团等活动的提醒需求。 今日待办：让用户清晰知晓当天任务。 易上手：方便新建和管理待办事项。 程序规划： 数据存储模块：运用 json 文件、对象和数组保存用户提醒任务详情，确保数据持久化与高效读写。 数据交互模块：作为模块间数据桥梁，保障程序流畅运行与协同工作。 界面模块：呈现可视化界面，方便用户交互操作。 提醒功能模块：实现提醒逻辑，包括时间设定、触发机制与多种提醒方式。 三、关键技术 json 和结构体应用：通过 todoINFO 结构体数组存放待办事项内容，利用 todoToJson 函数在关闭程序时将结构体转化为 json 对象存盘，借助 jsonArray 管理多个 json 对象，程序打开时用 jsonToTodo 函数转回结构体并添加到 Qlist 容器便于操作。 Qt 框架开发： 信号与槽机制：实现高效对象间事件通信，如设置待办事项点击确认按钮时新建结构体变量，逻辑清晰且代码耦合度低。 布局管理：多种布局管理器确保界面在不同电脑上视觉与操作良好。 类库资源：丰富类库用于创建各类可视化组件，如 QPushButton 类创建按钮。 用户体验支持：如实现背景切换动画，增强趣味性与体验感。 四、作品特色 提醒功能：借助 Windows 系统通知，在 Qtimer 定时器检测下，以醒目的系统通知弹出提醒事项内容与地点。\n背景切换：利用 QDateTime 变量、Qtimer 定时器和 Switch-case 结构实现一天内背景随时间切换壁纸，且有多组可选。 图形化界面：基于 Qt 框架打造，布局合理、按钮一目了然，易于上手操作。 五、项目信息 团队成员： 项目主导及核心代码：ZephyrBD JSON 转换方法：puuuuh 指导老师：CUIT计算机学院老师 版权与开源： 提交给学校的 Alpha 1.0 版本用于特定比赛，请勿外泄。（Github的Releases中的Alpha 1.0版本为公共版） 除背景图片组版权属于美国苹果公司外，其余内容遵循大赛共享协议，现在以 GPL - 2.0 协议开源到该 Github 仓库。 项目文件：包含 MCZS_TO_DO.pro、头文件（如 aboutus.h 等）、源文件（如 aboutus.cpp 等）、界面文件（如 aboutus.ui 等）、资源文件 res.qrc 及其他文件 version.rc。 ","date":"2025-01-02T00:00:00Z","image":"https://zephyrbd.github.io/images/cuitDRace/img1.png","permalink":"https://zephyrbd.github.io/p/cuitappdesignrace/","title":"智记清单（MCZS To Do）Alpha 1.0 发布"},{"content":"为什么MC 1.17 需要使用 Java 16 MC自从1.8就开始使用Java 8，到现在已经用了8个大版本了。mojang也决定从MC 1.17开始使用最近才发布的Java 16（官方给出的解释是有更好的优化，但我觉得应该是mojang用了Java 16的新语法），总的来说，这一举动是好的。\n对玩家有什么影响 显然，过去我们使用Java 8来打开MC，现在Java 8是不可能打开1.17了，那是不是把旧的Java删除就可以了？当然不行，旧版的Java可以帮助我们打开旧的MC版本，删除后就只可以玩1.17了，下面就讲述如何使Java 8和16共存。\n更新步骤一：更新启动器 在我的教程《如何安装Minecraft国际版》已经介绍了HMCL启动器的安装，现在就以HMCL启动器为例，讲述启动器的更新。 1.打开启动器，注意右上角的提示 2.点击它，看到下图所示界面 可以看到自从HMCL 3.3.184开始就支持Java 16了，不过考虑到兼容性，还是推荐更新到最新版（会有更新提示），现在点击右下角的更新出现下图所示界面。 表明开始更新，更新完成后会自动重启，然后就可以看到HMCL版本和刚才更新日志的版本一致了。 视频讲解 视频中是个简单方法，成功了就可以不看后面了（但启动器必须更新） 更新步骤二：Java 16和MC 1.17的安装 1.检测电脑位数\n这个我在如何安装Minecraft国际版已经讲了，不知道的可以去看看。 2.下载Java 16 64位点我 32位点我 3.解压下载的文件并且拷贝到MC文件夹 4.选择版本列表，然后点安装新游戏版本 选择1.17 选择Optifine 选择最新版本 Optifine选择成功后如图所示，然后点击安装 更新步骤三：MC 1.17启动前设置 1.安装成功后如图所示，点击设置 2.勾选启用游戏特定设置 3.选择Java 16的路径（按照图示界面点击） 有关其它的设置可以参考《如何安装Minecraft国际版》里面的讲解。 4.返回并启动游戏 以上自己安装Java 16的教程可以参考下面这个视频 ","date":"2021-06-24T00:00:00Z","image":"https://zephyrbd.github.io/images/htjava/img1.png","permalink":"https://zephyrbd.github.io/p/howtoupdatejava/","title":"如何更新到Java-16"},{"content":"为什么要端口映射？ 现在大部分人的宽带IP地址都是运营商分配给我们的，但一般情况下只会给我们内网IP地址，举个例子：10个人要上网，但10个公网IP太多了，那么就让10个人共用一个“网关”，再由“网关”联网，这样10个人就只用掉一个IP，但我的世界联机的时候，别人和你不在一个“网关”之下，那他就只可以找到你的“网关”，而不知道10个人中那个是你，这个时候就需要一个“中间人”来告诉他你到底是谁，然后你们就可以一起愉快玩耍了，这个“中间人”就是第三方服务器映射的IP\n如何进行端口映射 1.注册SAKURA FRP账号 SAKURA FRP是一个免费的端口映射网站，可以帮我们进行映射，打开网站后界面如图所示。 点击注册账号进行注册（注意：使用 中国大陆节点 必须完成实名认证）进入后如图所示。 2.下载SAKURA FRP客户端 点击上图所示的左侧边栏上的软件下载，打开后按图示点击，或者点我下载客户端 3.安装SAKURA FRP启动器并打开 回到官网，在管理面板上复制访问密钥 回到启动器粘贴并登陆 4.转发端口 打开需要联机的世界，选择对局域网开放 添加一个隧道（找到java那个，没有的话刷新一下，然后选择一个合适的转发服务器，点击创建） 打开隧道就可以了（弹出的提示框中的IP就是你朋友用的） 注意：本方法仅适用于正版玩家\n","date":"2021-03-13T00:00:00Z","image":"https://zephyrbd.github.io/images/htgoon/img1.png","permalink":"https://zephyrbd.github.io/p/howtousetheinternationalversionofminecrafttogoonline/","title":"如何使用国际版我的世界进行联机"},{"content":"为什么突然写这个 当下OLED屏幕弯折角度越来越大，再者之前看到了一个回形针做的一个关于曲面屏的视频，我不由得产生了一个想法——那就是用柔性屏做一个符合但又不局限于传统书本概念的书，所以接下来我就好好的说一下这个想法（本文仅仅阐述我这个概念性的想法，喷子勿看）\n怎样做才像一本书 ①书写 一本传统概念的书，首先要做的就是书写，这大多数电子产品都可以，但书写的体验我敢说绝对不如在真正的纸上书写，所以，我要探索的不仅仅是普通的书本书写，更要舒适的书写，现在能做到在OLED屏幕上写字就像在真纸上的，我只知道两个口碑不错的产品：\n苹果的Apple Pencil 华为的M-Pencil 在这方面，苹果要做的比华为早，书写的体验也是目前业界的佼佼者，假设这本书拥有Apple Pencil的技术，再加上几十块钱的书写膜，那写得舒服的这个问题就解决了，体验也能像这个视频一样。 ②弯折 一本传统的概念书籍来说，能做的第二件事就是正常的弯折，所以上面我提到了这样的OLED屏幕。 虽然这样可以弯折了，但仅仅只能翻折一次，所以要使用Galaxy Fold制作的方法来制造，但这也会使它像Galaxy Fold那样留下无法抹去的折痕，以及这个巨大的弯折半径。 看到这些照片后，相信你也会意识到这些问题都是无法忍受的，但是有一项新技术——ULP-NSSP，可以很好地解决这个问题，就像柔宇科技这个屏幕。 再次假设这本书拥有ULP-NSSP工艺制成的OLED屏幕，折痕和弯折半径的问题也将被解决。\n技术下的新功能 目前已实现了传统图书的功能，现在谈谈未来图书的功能。\n①增强现实（AR）和激光雷达扫描仪 借助于性能强劲的 CPU，比如高通骁龙处理器，再加上4800万像素以上的摄像头，实现了如下图所示的增强现实。 甚至像下面这样通过局域网连接来实现多台设备同时使用一个增强现实场景，这对教育方面将会有巨大的影响，试想老师通过AR技术讲解生物，物理，化学等科目所需演示的实验和模型，那是一件多么不可思议的事情啊！ 以及激光雷达扫描仪 激光雷达 (LiDAR 光探测和测距) 这项先进技术，是通过测量光触及物体并反射回来所需的时间，来确定距离。特制的激光雷达扫描仪利用直接飞行时间 (dToF)，测量室内或室外环境中从最远五米处反射回来的光。 它可从光子层面进行探测，并能以纳秒速度运行，为增强现实及更广泛的领域开启无尽可能。\n②文档的转换和在电子文档上书写 未来的书，当然不能仅仅是一本书，它应该是像上面那样，可以从网上购买各种书籍的版权，而不必支付印刷费用，这将对地球的环境保护做出巨大贡献，而且借助前文提到的强大的书写系统，就可以像阅读真书一般。\n甚至当做笔记本来使用，当你正处在课堂上时，第一个工作区可以查看课本，而第二个工作区用来充当笔记本（工作区后文会介绍），将教科书中的一段话截屏放进笔记本中，再做上注释，这很好地解决了学生记笔记的痛苦， 也可以把第二个工作区设置为练习册和参考书等辅助资料，从此学生的桌面上不再有成堆书本，取而代之的是一本这样的书。\n③多个可拆卸的屏幕和防盗技术 这本书应该有两个屏幕，其中一块是和处理器之类固定在书上的屏幕，另一块则可随意拆卸，为了方便解释，我用纸质笔记本来简单描述一下。 与此同时它还具有下图中的防盗功能，就像现在的手机一般，对丢失的设备进行远程定位、锁定、备份和删除，在保证个人资料安全的同时，也一定程度上解决了书本找不到的问题。 本文阐述了我对未来书籍的一些想法，但是我认为未来肯定不会止步于此，我也希望将来会有更多更好的科技产品服务于我们的生活。。\n资料来源 Apple Pencil—Apple中国\n增强现实—Apple中国\niPad Pro—Apple中国\niCloud—Apple中国\nHUAWEI M-Pencil 套装—华为官网\n柔宇科技—OLED屏幕\n2017 Apple 秋季发布会\n2018 Apple 秋季发布会\n回形针PaperClip—你究竟需要怎样的屏幕？\n","date":"2020-10-03T00:00:00Z","image":"https://zephyrbd.github.io/images/fubook/img1.png","permalink":"https://zephyrbd.github.io/p/thefuturebooks/","title":"我对未来书本的一个设想"},{"content":"安装Java（必须，游戏依赖） 1.查看电脑系统位数 右键此电脑（或者叫计算机或这台电脑），选择属性，如图所示（图片仅供参考） 记住系统位数，一会用得上\n2.打开下载Java的链接 32位系统版本点我\n64位系统版本点我\n下载完成后打开，一直下一步安装完成就可以了（安装成功截图如下） 使用Hello Minecraft Launcher启动器 1.下载和解压Hello Minecraft Launcher 首先，打开HMCL（注：Hello Minecraft Launcher以下均简称HMCL）在mcbbs的帖子，点击如图所示的链接（HMCL官网链接好像挂了，演示时先暂时用百度网盘分享） 为了方便，这里我把网盘链接拿过来了，不过还是建议去原贴下载。\n百度网盘下载地址 提取码: g4hd\n然后按如图所示的点击：\n选择HMCL版本 选择自己的系统（看不懂就选Windows） 打钩后下载 按图所示解压（过程不一定一样，取决于你的解压软件） 2.安装Minecraft 将HMCL启动器复制到自己喜欢的路径，然后双击打开 如果没有正版账号就输入个名字（最好英文） 有正版账号就选择正版登录 选择版本列表，然后点安装新游戏版本 选择自己需要的版本（这里以1.16.3做演示） 然后选择需要的插件和插件版本（强烈建议安装OptiFine，可以减轻渲染的负担，也可以不安装任何插件）（演示时安装OptiFine） 点击安装 安装完成后如图所示 返回后就可以启动游戏了 补充：关于游戏的配置详解 按图示进入配置页面 内存 首先要知道电脑的物理内存（和前面查看系统位数的方法一致） 计算机显示的是 GB，而 HMCL启动器显示的是 MB，因此在修改前要了解进率 1024MB=1GB\n设置内存的一些建议 游戏的内存至少有1024MB（1GB）（32位Java的只支持最高1024MB（1GB））（如果电脑连2048MB（2GB）物理内存都没有，你还是别玩了） 游戏的建议内存最好有4096MB（4GB）（如果自己加了70+的模组，一般建议直接上8192MB（8GB），前提是物理内存比8192MB（8GB）至少大2048MB（2GB）） 注意你的物理内存大小，分配给Minecraft的内存至少比物理内存少2048MB，如果内存不够就不要玩大型模组整合包了 在运行大型模组整合包时，如果需要同时使用OBS或其他录制软件录制视频，物理内存最好为12288 MB (12 GB)或更多，然后为系统保留4096 MB（4GB）的内存 其它设置建议 建议把分辨率设置为 1280*720 （主要因为是16:9的分辨率，方便截图和视频录制） 把启动器设置为 保持启动器可见 （这样方便防止低配电脑退出时卡死，也方便大型模组整合包调试） 如果大型模组整合包启动游戏出问题，可以把查看日志打开（前提你有一定的Java基础） 附：.minecraft目录详解图（仅供参考） ","date":"2020-09-20T00:00:00Z","image":"https://zephyrbd.github.io/images/htIsMC/img1.png","permalink":"https://zephyrbd.github.io/p/howtoinstallminecraft_old/","title":"如何安装我的世界国际版"}]